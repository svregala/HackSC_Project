import { EventHandler, Browser, remove } from '@syncfusion/ej2-base';
import { Animation, createElement } from '@syncfusion/ej2-base';
import { ScrollElements, createScrollSvg } from './scrollbar-elements';
import { getElement, minMax } from '../utils/helper';
import { linear } from '../../chart/index';
import { getScrollbarThemeColor } from '../model/theme';
/**
 * Scrollbar Base
 */
var ScrollBar = /** @class */ (function () {
    /**
     * Constructor for creating scrollbar
     * @param component
     * @param axis
     */
    function ScrollBar(component, axis) {
        this.component = component;
        this.elements = [];
        this.scrollElements = new ScrollElements();
        this.axis = axis;
        this.mouseMoveListener = this.scrollMouseMove.bind(this);
        this.mouseUpListener = this.scrollMouseUp.bind(this);
        this.animateDuration = 500;
        this.isPointer = Browser.isPointer;
        this.browserName = Browser.info.name;
    }
    /**
     * To Mouse x and y position
     * @param e
     */
    ScrollBar.prototype.getMouseXY = function (e) {
        var pageX;
        var pageY;
        var touchArg;
        if (e.type.indexOf('touch') > -1) {
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            pageX = e.clientX;
            pageY = e.clientY;
        }
        var svgRect = getElement('scrollBar_svg' + this.axis.name).getBoundingClientRect();
        this.mouseX = pageX - Math.max(svgRect.left, 0);
        this.mouseY = pageY - Math.max(svgRect.top, 0);
    };
    /**
     * Method to bind events for scrollbar svg object
     * @param element
     */
    ScrollBar.prototype.wireEvents = function (element) {
        EventHandler.add(element, Browser.touchStartEvent, this.scrollMouseDown, this);
        EventHandler.add(element, Browser.touchMoveEvent, this.scrollMouseMove, this);
        EventHandler.add(element, Browser.touchEndEvent, this.scrollMouseUp, this);
        EventHandler.add(element, 'mousewheel', this.scrollMouseWheel, this);
        window.addEventListener('mousemove', this.mouseMoveListener, false);
        window.addEventListener('mouseup', this.mouseUpListener, false);
    };
    /**
     * Method to remove events for srcollbar svg object
     * @param element
     */
    ScrollBar.prototype.unWireEvents = function (element) {
        EventHandler.remove(element, Browser.touchStartEvent, this.scrollMouseDown);
        EventHandler.remove(element, Browser.touchMoveEvent, this.scrollMouseMove);
        EventHandler.remove(element, Browser.touchEndEvent, this.scrollMouseUp);
        EventHandler.remove(element, 'mousewheel', this.scrollMouseWheel);
        window.removeEventListener('mousemove', this.mouseMoveListener, false);
        window.removeEventListener('mouseup', this.mouseUpListener, false);
    };
    /**
     * Handles the mouse down on scrollbar
     * @param e
     */
    ScrollBar.prototype.scrollMouseDown = function (e) {
        var id = e.target.id;
        var elem = this.scrollElements;
        this.getMouseXY(e);
        this.isResizeLeft = this.isExist(id, '_leftCircle_') || this.isExist(id, '_leftArrow_');
        this.isResizeRight = this.isExist(id, '_rightCircle_') || this.isExist(id, '_rightArrow_');
        this.previousXY = this.isVertical ? this.mouseY : this.mouseX;
        this.previousWidth = elem.thumbRectWidth;
        this.previousRectX = elem.thumbRectX;
        if (this.isExist(id, 'scrollBarThumb_')) {
            this.isThumbDrag = true;
            this.svgObject.style.cursor = '-webkit-grabbing';
        }
        else if (this.isExist(id, 'scrollBarBackRect_')) {
            var currentX = this.moveLength(this.previousXY, this.previousRectX, 8);
            if (this.animateDuration) {
                currentX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;
                this.performAnimation(elem.thumbRectX, currentX);
            }
            else {
                elem.thumbRectX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;
                this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);
                this.setZoomFactorPosition(elem.thumbRectX, elem.thumbRectWidth);
            }
        }
    };
    /**
     * To check the matched string
     * @param id
     * @param match
     */
    ScrollBar.prototype.isExist = function (id, match) {
        return id.indexOf(match) > -1;
    };
    /**
     * To check current poisition is within scrollbar region
     * @param currentX
     */
    ScrollBar.prototype.isWithIn = function (currentX) {
        var circleRadius = 8;
        return (currentX - circleRadius >= 0 &&
            currentX + this.scrollElements.thumbRectWidth + circleRadius <= this.width);
    };
    /**
     * Method to find move length of thumb
     * @param mouseXY
     * @param thumbX
     * @param circleRadius
     */
    ScrollBar.prototype.moveLength = function (mouseXY, thumbX, circleRadius) {
        var moveLength = (10 / 100) * (this.width - circleRadius * 2);
        if (mouseXY < thumbX) {
            moveLength = thumbX - (thumbX - moveLength > circleRadius ? moveLength : circleRadius);
        }
        else {
            moveLength = thumbX + (thumbX + this.scrollElements.thumbRectWidth + moveLength < this.width - circleRadius ?
                moveLength : circleRadius);
        }
        return moveLength;
    };
    /**
     * Method to calculate zoom factor and position
     * @param currentX
     * @param currentWidth
     */
    ScrollBar.prototype.setZoomFactorPosition = function (currentX, currentWidth) {
        var axis = this.axis;
        this.isScrollUI = true;
        var circleRadius = 8;
        var circleWidth = 1;
        var currentScrollWidth = currentX + currentWidth + circleRadius + circleWidth;
        var currentZPWidth = circleRadius + (circleWidth / 2);
        this.zoomPosition = (currentX - (currentX - currentZPWidth <= 0 ? currentZPWidth : 0)) / (this.isVertical
            ? axis.rect.height : this.width);
        this.zoomFactor = (currentWidth + (currentScrollWidth === this.width ? circleRadius + circleWidth : 0)) / (this.isVertical
            ? axis.rect.height : this.width);
        axis.zoomPosition = this.zoomPosition;
        axis.zoomFactor = this.zoomFactor;
    };
    /**
     * Handles the mouse move on scrollbar
     * @param e
     */
    ScrollBar.prototype.scrollMouseMove = function (e) {
        var target = e.target;
        var elem = this.scrollElements;
        this.getMouseXY(e);
        this.setCursor(target);
        this.setTheme(target);
        var style = this.scrollbarThemeStyle;
        var mouseXY = this.isVertical ? this.mouseY : this.mouseX;
        if (this.isThumbDrag) {
            this.svgObject.style.cursor = '-webkit-grabbing';
            var currentX = elem.thumbRectX + (mouseXY - this.previousXY);
            if (mouseXY >= 0 && mouseXY <= currentX + elem.thumbRectWidth) {
                elem.thumbRectX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;
                this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);
                this.previousXY = mouseXY;
                this.setZoomFactorPosition(currentX, elem.thumbRectWidth);
            }
        }
        else if (this.isResizeLeft || this.isResizeRight) {
            this.resizeThumb(e);
        }
    };
    /**
     * Handles the mouse wheel on scrollbar
     * @param e
     */
    ScrollBar.prototype.scrollMouseWheel = function (e) {
        var svgRect = getElement('scrollBar_svg' + this.axis.name).getBoundingClientRect();
        this.mouseX = e.clientX - Math.max(svgRect.left, 0);
        this.mouseY = e.clientY - Math.max(svgRect.top, 0);
        var origin = 0.5;
        var elem = this.scrollElements;
        var axis = this.axis;
        var direction = (this.browserName === 'mozilla' && !this.isPointer) ?
            -(e.detail) / 3 > 0 ? 1 : -1 : (e.wheelDelta / 120) > 0 ? 1 : -1;
        var cumulative;
        cumulative = Math.max(Math.max(1 / minMax(axis.zoomFactor, 0, 1), 1) + (0.25 * direction), 1);
        if (cumulative >= 1) {
            origin = axis.orientation === 'Horizontal' ? this.mouseX / axis.rect.width : 1 - (this.mouseY / axis.rect.height);
            origin = origin > 1 ? 1 : origin < 0 ? 0 : origin;
            this.zoomFactor = (cumulative === 1) ? 1 : minMax(1 / cumulative, 0, 1);
            this.zoomPosition = (cumulative === 1) ? 0 : axis.zoomPosition + ((axis.zoomFactor - this.zoomFactor) * origin);
        }
        elem.thumbRectX = this.isWithIn(this.zoomPosition * this.width) ? this.zoomPosition * this.width : elem.thumbRectX;
        this.isScrollUI = true;
        this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);
        axis.zoomFactor = this.zoomFactor;
        axis.zoomPosition = this.zoomPosition;
    };
    /**
     * Handles the mouse up on scrollbar
     * @param e
     */
    ScrollBar.prototype.scrollMouseUp = function (e) {
        var circleRadius = 8;
        var circleWidth = 1;
        this.startX = this.scrollElements.thumbRectX;
        var currentScrollWidth = this.startX + this.scrollElements.thumbRectWidth + circleRadius + circleWidth;
        var currentZPWidth = circleRadius + (circleWidth / 2);
        if (this.isResizeLeft || this.isResizeRight) {
            this.axis.zoomFactor = (currentScrollWidth >= this.width - 1 && (this.startX - currentZPWidth) <= 0) ? 1 : this.zoomFactor;
        }
        this.isThumbDrag = false;
        this.isResizeLeft = false;
        this.isResizeRight = false;
    };
    /**
     * To render scroll bar
     * @private
     */
    ScrollBar.prototype.render = function () {
        this.getDefaults();
        this.getTheme();
        this.removeScrollSvg();
        createScrollSvg(this, this.component.renderer);
        this.wireEvents(this.svgObject);
        this.svgObject.appendChild(this.scrollElements.renderElements(this, this.component.renderer));
        return this.svgObject;
    };
    /**
     * Theming for scrollabr
     */
    ScrollBar.prototype.getTheme = function () {
        this.scrollbarThemeStyle = getScrollbarThemeColor(this.component.theme);
    };
    /**
     * Method to remove existing scrollbar
     */
    ScrollBar.prototype.removeScrollSvg = function () {
        if (document.getElementById('scrollBar_svg' + this.axis.name)) {
            remove(document.getElementById('scrollBar_svg' + this.axis.name));
        }
    };
    /**
     * Method to set cursor fpr scrollbar
     * @param target
     */
    ScrollBar.prototype.setCursor = function (target) {
        var id = target.id;
        this.svgObject.style.cursor = id.indexOf('scrollBarThumb_') > -1 || id.indexOf('_gripCircle') > -1 ?
            '-webkit-grab' : (id.indexOf('Circle_') > -1 || id.indexOf('Arrow_') > -1) ? this.isVertical ? 'ns-resize' :
            'ew-resize' : 'auto';
    };
    /**
     * Method to set theme for sollbar
     * @param target
     */
    ScrollBar.prototype.setTheme = function (target) {
        var id = target.id;
        var isLeftHover = id.indexOf('_leftCircle_') > -1 || id.indexOf('_leftArrow_') > -1;
        var isRightHover = id.indexOf('_rightCircle_') > -1 || id.indexOf('_rightArrow_') > -1;
        var style = this.scrollbarThemeStyle;
        var leftArrowEle = this.scrollElements.leftArrowEle;
        var rightArrowEle = this.scrollElements.rightArrowEle;
        var leftCircleEle = this.scrollElements.leftCircleEle;
        var rightCircleEle = this.scrollElements.rightCircleEle;
        var isAxis = this.isCurrentAxis(target, leftArrowEle);
        leftCircleEle.style.fill = isLeftHover && isAxis ? style.circleHover : style.circle;
        rightCircleEle.style.fill = isRightHover && isAxis ? style.circleHover : style.circle;
        leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;
        rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;
        if (this.component.theme === 'Highcontrast') {
            leftArrowEle.style.fill = isLeftHover && isAxis ? style.arrowHover : style.arrow;
            leftArrowEle.style.stroke = isLeftHover && isAxis ? style.arrowHover : style.arrow;
            rightArrowEle.style.fill = isRightHover && isAxis ? style.arrowHover : style.arrow;
            rightArrowEle.style.stroke = isRightHover && isAxis ? style.arrowHover : style.arrow;
            leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;
            rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;
        }
    };
    /**
     * To check current axis
     * @param target
     * @param ele
     */
    ScrollBar.prototype.isCurrentAxis = function (target, ele) {
        return (target.id.split('_')[2] === ele.id.split('_')[2]);
    };
    /**
     * Method to resize thumb
     * @param e
     */
    ScrollBar.prototype.resizeThumb = function (e) {
        var currentWidth;
        var circleRadius = 8;
        var padding = 5;
        var gripWidth = 14;
        var elem = this.scrollElements;
        var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;
        var thumbX = this.previousRectX;
        var mouseXY = this.isVertical ? this.mouseY : this.mouseX;
        var diff = Math.abs(this.previousXY - mouseXY);
        if (this.isResizeLeft && mouseXY >= 0) {
            var currentX = thumbX + (mouseXY > this.previousXY ? diff : -diff);
            currentWidth = currentX - circleRadius >= 0 ? this.previousWidth + (mouseXY > this.previousXY ? -diff : diff) :
                this.previousWidth;
            currentX = currentX - circleRadius >= 0 ? currentX : thumbX;
            if (currentWidth >= minThumbWidth && mouseXY < currentX + currentWidth) {
                this.scrollElements.thumbRectX = this.previousRectX = currentX;
                this.scrollElements.thumbRectWidth = this.previousWidth = currentWidth;
                this.previousXY = mouseXY;
                this.positionThumb(currentX, currentWidth);
                this.setZoomFactorPosition(currentX, currentWidth);
            }
        }
        else if (this.isResizeRight) {
            currentWidth = mouseXY >= minThumbWidth + this.scrollElements.thumbRectX && mouseXY <= this.width - circleRadius ?
                mouseXY - this.scrollElements.thumbRectX : this.previousWidth;
            this.scrollElements.thumbRectWidth = this.previousWidth = currentWidth;
            this.previousXY = mouseXY;
            this.positionThumb(this.startX, currentWidth);
            this.setZoomFactorPosition(this.startX, currentWidth);
        }
    };
    /**
     * Method to position the scrollbar thumb
     * @param currentX
     * @param currentWidth
     */
    ScrollBar.prototype.positionThumb = function (currentX, currentWidth) {
        var circlePadding = 3;
        var elem = this.scrollElements;
        var gripWidth = 14;
        var gripCircleDiameter = 2;
        var padding = gripWidth / 2 - gripCircleDiameter;
        elem.slider.setAttribute('x', currentX.toString());
        elem.slider.setAttribute('width', currentWidth.toString());
        elem.leftCircleEle.setAttribute('cx', currentX.toString());
        elem.rightCircleEle.setAttribute('cx', (currentX + currentWidth).toString());
        elem.setArrowDirection(currentX, currentWidth, this.height);
        elem.gripCircle.setAttribute('transform', 'translate(' + (currentX + currentWidth / 2 + ((this.isVertical ? 1 : -1) * padding)) +
            ',' + (this.isVertical ? '10' : '5') + ') rotate(' + (this.isVertical ? '180' : '0') + ')');
    };
    /**
     * Method to get default values
     */
    ScrollBar.prototype.getDefaults = function () {
        var circleRadius = 8;
        var padding = 5;
        var gripWidth = 14;
        var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;
        var axis = this.axis;
        this.isVertical = axis.orientation === 'Vertical';
        var currentWidth = axis.zoomFactor * (this.isVertical ? axis.rect.height : axis.rect.width);
        currentWidth = currentWidth > minThumbWidth ? currentWidth : minThumbWidth;
        this.scrollX = axis.rect.x;
        this.scrollY = axis.rect.y;
        this.width = this.isVertical ? axis.rect.height : axis.rect.width;
        this.height = 16;
        var currentX = axis.zoomPosition * (this.isVertical ? axis.rect.height : this.width);
        this.scrollElements.thumbRectX = currentX > circleRadius ? currentX : circleRadius;
        this.scrollElements.thumbRectWidth = ((currentWidth + this.scrollElements.thumbRectX) < this.width - (circleRadius * 2))
            ? currentWidth : this.width - this.scrollElements.thumbRectX - circleRadius;
    };
    /**
     * Method for injecting scrollbar module
     * @param axis
     * @param component
     */
    ScrollBar.prototype.injectTo = function (axis, component) {
        axis.zoomingScrollBar = new ScrollBar(component, axis);
    };
    /**
     * Animation Calculation for scrollbar
     * @param previous
     * @param current
     */
    ScrollBar.prototype.performAnimation = function (previous, current) {
        var _this = this;
        var currentX;
        var width = this.scrollElements.thumbRectWidth;
        new Animation({}).animate(createElement('div'), {
            duration: this.animateDuration,
            progress: function (args) {
                currentX = linear(args.timeStamp, 0, current - previous, args.duration) + previous;
                _this.positionThumb(currentX, width);
                _this.setZoomFactorPosition(currentX, width);
            },
            end: function (model) {
                _this.scrollElements.thumbRectX = current;
                _this.startX = current;
                _this.positionThumb(current, width);
                _this.setZoomFactorPosition(current, width);
            }
        });
    };
    /**
     * Method to destroy scrollbar
     */
    ScrollBar.prototype.destroy = function () {
        var _this = this;
        if (this.axes) {
            this.axes.map(function (axis) {
                axis.zoomingScrollBar.destroy();
            });
        }
        else {
            this.elements.map(function (element) {
                _this.unWireEvents(element);
                remove(element.firstChild);
            });
            this.elements = [];
        }
    };
    /**
     * Method to get scrollbar module name
     */
    ScrollBar.prototype.getModuleName = function () {
        return 'ScrollBar';
    };
    return ScrollBar;
}());
export { ScrollBar };
