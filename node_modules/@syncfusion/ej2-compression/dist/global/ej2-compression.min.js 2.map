{"version":3,"file":"ej2-compression.min.js","sources":["../../node_modules/@syncfusion/ej2-file-utils/dist/src/es5/encoding.js","../../node_modules/@syncfusion/ej2-file-utils/dist/src/es5/save.js","../../node_modules/@syncfusion/ej2-file-utils/dist/src/es5/xml-writer.js","../../node_modules/@syncfusion/ej2-file-utils/dist/src/es5/stream-writer.js","../src/es5/compression-writer.js","../src/es5/zip-archive.js"],"sourcesContent":["/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\nvar Encoding = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n     * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n     */\n    function Encoding(includeBom) {\n        this.emitBOM = true;\n        this.encodingType = 'Ansi';\n        this.initBOM(includeBom);\n    }\n    Object.defineProperty(Encoding.prototype, \"includeBom\", {\n        /**\n         * Gets a value indicating whether to write a Unicode byte order mark\n         * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n         */\n        get: function () {\n            return this.emitBOM;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Encoding.prototype, \"type\", {\n        /**\n         * Gets the encoding type.\n         * @returns EncodingType\n         */\n        get: function () {\n            return this.encodingType;\n        },\n        /**\n         * Sets the encoding type.\n         * @param  {EncodingType} value\n         */\n        set: function (value) {\n            this.encodingType = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize the includeBom to emit BOM or Not\n     * @param  {boolean} includeBom\n     */\n    Encoding.prototype.initBOM = function (includeBom) {\n        if (includeBom === undefined || includeBom === null) {\n            this.emitBOM = true;\n        }\n        else {\n            this.emitBOM = includeBom;\n        }\n    };\n    /**\n     * Calculates the number of bytes produced by encoding the characters in the specified string\n     * @param  {string} chars - The string containing the set of characters to encode\n     * @returns {number} - The number of bytes produced by encoding the specified characters\n     */\n    Encoding.prototype.getByteCount = function (chars) {\n        var byteCount = 0;\n        validateNullOrUndefined(chars, 'string');\n        if (chars === '') {\n            var byte = this.utf8Len(chars.charCodeAt(0));\n            return byte;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        return this.getByteCountInternal(chars, 0, chars.length);\n    };\n    /**\n     * Return the Byte of character\n     * @param  {number} codePoint\n     * @returns {number}\n     */\n    Encoding.prototype.utf8Len = function (codePoint) {\n        var bytes = codePoint <= 0x7F ? 1 :\n            codePoint <= 0x7FF ? 2 :\n                codePoint <= 0xFFFF ? 3 :\n                    codePoint <= 0x1FFFFF ? 4 : 0;\n        return bytes;\n    };\n    /**\n     * for 4 byte character return surrogate pair true, otherwise false\n     * @param  {number} codeUnit\n     * @returns {boolean}\n     */\n    Encoding.prototype.isHighSurrogate = function (codeUnit) {\n        return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n    };\n    /**\n     * for 4byte character generate the surrogate pair\n     * @param  {number} highCodeUnit\n     * @param  {number} lowCodeUnit\n     */\n    Encoding.prototype.toCodepoint = function (highCodeUnit, lowCodeUnit) {\n        highCodeUnit = (0x3FF & highCodeUnit) << 10;\n        var u = highCodeUnit | (0x3FF & lowCodeUnit);\n        return u + 0x10000;\n    };\n    /**\n     * private method to get the byte count for specific charindex and count\n     * @param  {string} chars\n     * @param  {number} charIndex\n     * @param  {number} charCount\n     */\n    Encoding.prototype.getByteCountInternal = function (chars, charIndex, charCount) {\n        var byteCount = 0;\n        if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n            var isUtf8 = this.encodingType === 'Utf8';\n            for (var i = 0; i < charCount; i++) {\n                var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n                if (this.isHighSurrogate(charCode)) {\n                    if (isUtf8) {\n                        var high = charCode;\n                        var low = chars.charCodeAt(++charIndex);\n                        byteCount += this.utf8Len(this.toCodepoint(high, low));\n                    }\n                    else {\n                        byteCount += 4;\n                        ++i;\n                    }\n                }\n                else {\n                    if (isUtf8) {\n                        byteCount += this.utf8Len(charCode);\n                    }\n                    else {\n                        byteCount += 2;\n                    }\n                }\n                if (isUtf8) {\n                    charIndex++;\n                }\n            }\n            return byteCount;\n        }\n        else {\n            byteCount = charCount;\n            return byteCount;\n        }\n    };\n    /**\n     * Encodes a set of characters from the specified string into the ArrayBuffer.\n     * @param  {string} s- The string containing the set of characters to encode\n     * @param  {number} charIndex-The index of the first character to encode.\n     * @param  {number} charCount- The number of characters to encode.\n     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n     */\n    Encoding.prototype.getBytes = function (s, charIndex, charCount) {\n        validateNullOrUndefined(s, 'string');\n        validateNullOrUndefined(charIndex, 'charIndex');\n        validateNullOrUndefined(charCount, 'charCount');\n        if (charIndex < 0 || charCount < 0) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n        }\n        if (s.length - charIndex < charCount) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n        }\n        var bytes;\n        if (s === '') {\n            bytes = new ArrayBuffer(0);\n            return bytes;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        var byteCount = this.getByteCountInternal(s, charIndex, charCount);\n        switch (this.type) {\n            case 'Utf8':\n                bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            case 'Unicode':\n                bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            default:\n                bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n        }\n    };\n    /**\n     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n     * @param  {number} index- The index of the first byte to decode.\n     * @param  {number} count- The number of bytes to decode.\n     * @returns {string} - The string that contains the resulting set of characters.\n     */\n    Encoding.prototype.getString = function (bytes, index, count) {\n        validateNullOrUndefined(bytes, 'bytes');\n        validateNullOrUndefined(index, 'index');\n        validateNullOrUndefined(count, 'count');\n        if (index < 0 || count < 0) {\n            throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n        }\n        if (bytes.byteLength - index < count) {\n            throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n        }\n        if (bytes.byteLength === 0 || count === 0) {\n            return '';\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        var out = '';\n        var byteCal = new Uint8Array(bytes);\n        switch (this.type) {\n            case 'Utf8':\n                var s = this.getStringOfUtf8Encoding(byteCal, index, count);\n                return s;\n            case 'Unicode':\n                var byteUnicode = new Uint16Array(bytes);\n                out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n                return out;\n            default:\n                var j = index;\n                for (var i = 0; i < count; i++) {\n                    var c = byteCal[j];\n                    out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n                    j++;\n                }\n                return out;\n        }\n    };\n    Encoding.prototype.getBytesOfAnsiEncoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var bufview = new Uint8Array(bytes);\n        var k = 0;\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(charIndex++);\n            if (charcode < 0x800) {\n                bufview[k] = charcode;\n            }\n            else {\n                bufview[k] = 63; //replacement character '?'\n            }\n            k++;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getBytesOfUtf8Encoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var uint = new Uint8Array(bytes);\n        var index = charIndex;\n        var j = 0;\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(index);\n            if (charcode <= 0x7F) {\n                uint[j] = charcode;\n            }\n            else if (charcode < 0x800) {\n                uint[j] = 0xc0 | (charcode >> 6);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else if ((charcode < 0xd800 || charcode >= 0xe000)) {\n                uint[j] = 0xe0 | (charcode >> 12);\n                uint[++j] = 0x80 | ((charcode >> 6) & 0x3f);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else {\n                uint[j] = 0xef;\n                uint[++j] = 0xbf;\n                uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n            }\n            ++j;\n            ++index;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getBytesOfUnicodeEncoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var uint16 = new Uint16Array(bytes);\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(i);\n            uint16[i] = charcode;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getStringOfUtf8Encoding = function (byteCal, index, count) {\n        var j = 0;\n        var i = index;\n        var s = '';\n        for (j; j < count; j++) {\n            var c = byteCal[i++];\n            while (i > byteCal.length) {\n                return s;\n            }\n            if (c > 127) {\n                if (c > 191 && c < 224 && i < count) {\n                    c = (c & 31) << 6 | byteCal[i] & 63;\n                }\n                else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n                    c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n                    c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                ++i;\n            }\n            s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n        }\n        return s;\n    };\n    Encoding.prototype.getStringofUnicodeEncoding = function (byteUni, index, count) {\n        if (count > byteUni.length) {\n            throw new RangeError('ArgumentOutOfRange_Count');\n        }\n        var byte16 = new Uint16Array(count);\n        var out = '';\n        for (var i = 0; i < count && i < byteUni.length; i++) {\n            byte16[i] = byteUni[index++];\n        }\n        out = String.fromCharCode.apply(null, byte16);\n        return out;\n    };\n    /**\n     * To clear the encoding instance\n     * @return {void}\n     */\n    Encoding.prototype.destroy = function () {\n        this.emitBOM = undefined;\n        this.encodingType = undefined;\n    };\n    return Encoding;\n}());\nexport { Encoding };\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\nexport function validateNullOrUndefined(value, message) {\n    if (value === null || value === undefined) {\n        throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n    }\n}\n","/**\n * Save class provide method to save file\n * ```typescript\n * let blob : Blob = new Blob([''], { type: 'text/plain' });\n * Save.save('fileName.txt',blob);\n */\nvar Save = /** @class */ (function () {\n    /**\n     * Initialize new instance of {save}\n     */\n    function Save() {\n        // tslint:disable\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName- file name to save.\n     * @param  {Blob} buffer- the content to write in file\n     * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not\n     * @returns {void}\n     */\n    Save.save = function (fileName, buffer) {\n        if (fileName === null || fileName === undefined || fileName === '') {\n            throw new Error('ArgumentException: fileName cannot be undefined, null or empty');\n        }\n        var extension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);\n        var mimeType = this.getMimeType(extension);\n        if (mimeType !== '') {\n            buffer = new Blob([buffer], { type: mimeType });\n        }\n        if (this.isMicrosoftBrowser) {\n            navigator.msSaveBlob(buffer, fileName);\n        }\n        else {\n            var downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n            this.saveInternal(fileName, extension, buffer, downloadLink, 'download' in downloadLink);\n        }\n    };\n    Save.saveInternal = function (fileName, extension, buffer, downloadLink, hasDownloadAttribute) {\n        if (hasDownloadAttribute) {\n            downloadLink.download = fileName;\n            var dataUrl_1 = window.URL.createObjectURL(buffer);\n            downloadLink.href = dataUrl_1;\n            var event_1 = document.createEvent('MouseEvent');\n            event_1.initEvent('click', true, true);\n            downloadLink.dispatchEvent(event_1);\n            setTimeout(function () {\n                window.URL.revokeObjectURL(dataUrl_1);\n                dataUrl_1 = undefined;\n            });\n        }\n        else {\n            if (extension !== 'docx' && extension !== 'xlsx') {\n                var url = window.URL.createObjectURL(buffer);\n                var isPopupBlocked = window.open(url, '_blank');\n                if (!isPopupBlocked) {\n                    window.location.href = url;\n                }\n            }\n            else {\n                var reader_1 = new FileReader();\n                reader_1.onloadend = function () {\n                    var isPopupBlocked = window.open(reader_1.result, '_blank');\n                    if (!isPopupBlocked) {\n                        window.location.href = reader_1.result;\n                    }\n                };\n                reader_1.readAsDataURL(buffer);\n            }\n        }\n    };\n    /**\n     *\n     * @param {string} extension - get mime type of the specified extension\n     * @private\n     */\n    Save.getMimeType = function (extension) {\n        var mimeType = '';\n        switch (extension) {\n            case 'html':\n                mimeType = 'text/html';\n                break;\n            case 'pdf':\n                mimeType = 'application/pdf';\n                break;\n            case 'docx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n                break;\n            case 'xlsx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n                break;\n            case 'txt':\n                mimeType = 'text/plain';\n                break;\n        }\n        return mimeType;\n    };\n    return Save;\n}());\nexport { Save };\n","import { Save } from './save';\n/**\n * XmlWriter class provide method to create XML data\n */\nvar XmlWriter = /** @class */ (function () {\n    /**\n     * Initialize new instance of {XmlWriter}\n     */\n    function XmlWriter() {\n        this.contentPos = 0;\n        this.bufferText = '';\n        this.bufferBlob = new Blob([''], { type: 'text/plain' });\n        this.currentState = 'Initial';\n        this.namespaceStack = [];\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[0].set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[1].set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[2].set('', '', 'Implied');\n        this.elementStack = [];\n        this.elementStack.push(new XmlElement());\n        this.elementStack[0].set('', '', '', this.namespaceStack.length - 1);\n        this.attributeStack = [];\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(XmlWriter.prototype, \"buffer\", {\n        /**\n         * Gets the content written to the {XmlWriter} as Blob.\n         * @returns {Blob}\n         */\n        get: function () {\n            this.flush();\n            return this.bufferBlob;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Writes processing instruction with a space between the name and text\n     * @param {string} name - name of the processing instruction\n     * @param {string} text - text to write in the processing instruction\n     * @throws ArgumentException\n     * @throws InvalidArgumentException\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeProcessingInstruction = function (name, text) {\n        if (name === undefined || name === null || name.length === 0) {\n            throw new Error('ArgumentException: name should not be undefined, null or empty');\n        }\n        this.checkName(name);\n        if (text === undefined || text === null) {\n            text = '';\n        }\n        if (name.length === 3 && name === 'xml') {\n            if (this.currentState !== 'Initial') {\n                // tslint:disable-next-line:max-line-length\n                throw new Error('InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it');\n            }\n        }\n        if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        else {\n            this.writeStartDocument();\n            this.writeProcessingInstructionInternal(name, text);\n        }\n    };\n    /**\n     * Writes Xml declaration with version and standalone attribute\n     * @param {boolean} standalone - if true it write standalone=yes else standalone=no\n     * @throws InvalidOperation\n     */\n    XmlWriter.prototype.writeStartDocument = function (standalone) {\n        if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        this.currentState = 'StartDocument';\n        this.rawText('<?xml version=\"1.0\" encoding=\"utf-8');\n        if (standalone !== null && standalone !== undefined) {\n            this.rawText('\" standalone=\"');\n            this.rawText(standalone ? 'yes' : 'no');\n        }\n        this.rawText('\"?>');\n    };\n    /**\n     * Closes any open tag or attribute and write the state back to start\n     */\n    XmlWriter.prototype.writeEndDocument = function () {\n        while (this.elementStack.length - 1 > 0) {\n            this.writeEndElement();\n        }\n        this.currentState = 'EndDocument';\n        this.flush();\n    };\n    /**\n     * Writes the specified start tag and associates it with the given namespace and prefix.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName -localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @throws ArgumentException\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeStartElement = function (prefix, localName, namespace) {\n        if (this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        if (localName === undefined || localName === null || localName.length === 0) {\n            throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n        }\n        this.checkName(localName);\n        if (this.currentState === 'Initial') {\n            this.writeStartDocument();\n        }\n        if (this.currentState === 'StartElement') {\n            this.startElementContent();\n        }\n        this.currentState = 'StartElement';\n        if (prefix === undefined || prefix === null) {\n            if (namespace !== undefined && namespace !== null) {\n                prefix = this.lookupPrefix(namespace);\n            }\n            if (prefix === undefined || prefix === null) {\n                prefix = '';\n            }\n        }\n        else if (prefix.length > 0) {\n            if (namespace === undefined || namespace === null) {\n                namespace = this.lookupNamespace(prefix);\n            }\n            if (namespace === undefined || namespace === null || (namespace !== undefined && namespace.length === 0)) {\n                throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');\n            }\n        }\n        if (namespace === undefined || namespace === null) {\n            namespace = this.lookupNamespace(prefix);\n        }\n        this.writeStartElementInternal(prefix, localName, namespace);\n    };\n    /**\n     * Closes one element and pop corresponding namespace scope\n     */\n    XmlWriter.prototype.writeEndElement = function () {\n        if (this.currentState === 'StartElement') {\n            this.startElementContent();\n            this.currentState = 'ElementContent';\n        }\n        else if (this.currentState === 'ElementContent') {\n            this.currentState = 'ElementContent';\n        }\n        this.currentState = 'EndElement';\n        var top = this.elementStack.length - 1;\n        this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);\n        this.namespaceStack.splice(this.elementStack[top].previousTop + 1);\n        this.elementStack.splice(top);\n        if (this.bufferText.length > 10240) {\n            this.flush();\n        }\n    };\n    /**\n     * Writes an element with the specified prefix, local name, namespace URI, and value.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n    XmlWriter.prototype.writeElementString = function (prefix, localName, namespace, value) {\n        this.writeStartElement(prefix, localName, namespace);\n        if (value !== undefined && value !== null && value.length !== 0) {\n            this.writeString(value);\n        }\n        this.writeEndElement();\n    };\n    /**\n     * Writes out the attribute with the specified prefix, local name, namespace URI, and value\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n    XmlWriter.prototype.writeAttributeString = function (prefix, localName, namespace, value) {\n        this.writeStartAttribute(prefix, localName, namespace, value);\n        this.writeStringInternal(value, true);\n        this.writeEndAttribute();\n    };\n    /**\n     * Writes the given text content\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeString = function (text) {\n        this.writeInternal(text, false);\n    };\n    /**\n     * Write given text as raw data\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeRaw = function (text) {\n        this.writeInternal(text, true);\n    };\n    XmlWriter.prototype.writeInternal = function (text, isRawString) {\n        if (text === undefined || text === null) {\n            return;\n        }\n        else {\n            if (this.currentState !== 'StartElement' && this.currentState !== 'ElementContent') {\n                throw new Error('InvalidOperationException: Wrong Token');\n            }\n            if (this.currentState === 'StartElement') {\n                this.startElementContent();\n            }\n            this.currentState = 'ElementContent';\n            if (isRawString) {\n                this.rawText(text);\n            }\n            else {\n                this.writeStringInternal(text, false);\n            }\n        }\n    };\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param {string} fileName - file name\n     */\n    XmlWriter.prototype.save = function (fileName) {\n        while (this.elementStack.length - 1 > 0) {\n            this.writeEndElement();\n        }\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    };\n    /**\n     * Releases the resources used by XmlWriter.\n     */\n    XmlWriter.prototype.destroy = function () {\n        this.bufferBlob = undefined;\n        for (var i = 0; i < this.namespaceStack.length; i++) {\n            this.namespaceStack[i].destroy();\n        }\n        this.namespaceStack = [];\n        for (var i = 0; i < this.elementStack.length; i++) {\n            this.elementStack[i].destroy();\n        }\n        this.elementStack = [];\n        this.bufferText = '';\n        this.contentPos = 0;\n    };\n    XmlWriter.prototype.flush = function () {\n        if (this.bufferBlob === undefined) {\n            return;\n        }\n        this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], { type: 'text/plain' });\n        this.bufferText = '';\n    };\n    XmlWriter.prototype.writeProcessingInstructionInternal = function (name, text) {\n        this.bufferText += '<?';\n        this.rawText(name);\n        if (text.length > 0) {\n            this.bufferText += ' ';\n            text = text.replace(/\\?\\>/g, '? >');\n            this.bufferText += text;\n        }\n        this.bufferText += '?';\n        this.bufferText += '>';\n    };\n    XmlWriter.prototype.writeStartAttribute = function (prefix, localName, namespace, value) {\n        if (localName === undefined || localName === null || localName.length === 0) {\n            if (prefix === 'xmlns') {\n                localName = 'xmlns';\n                prefix = '';\n            }\n            else {\n                throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n            }\n        }\n        if (this.currentState !== 'StartElement') {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        this.checkName(localName);\n        this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);\n    };\n    XmlWriter.prototype.writeStartAttributePrefixAndNameSpace = function (prefix, localName, namespace, value) {\n        if (prefix === undefined || prefix === null) {\n            if (namespace !== undefined && namespace !== null) {\n                if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {\n                    prefix = this.lookupPrefix(namespace);\n                }\n            }\n            if (prefix === undefined || prefix === null) {\n                prefix = '';\n            }\n        }\n        if (namespace === undefined || namespace === null) {\n            if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n                namespace = this.lookupNamespace(prefix);\n            }\n            if (namespace === undefined || namespace === null) {\n                namespace = '';\n            }\n        }\n        this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);\n    };\n    XmlWriter.prototype.writeStartAttributeSpecialAttribute = function (prefix, localName, namespace, value) {\n        if (prefix.length === 0) {\n            if (localName[0] === 'x' && localName === 'xmlns') {\n                this.skipPushAndWrite(prefix, localName, namespace);\n                this.pushNamespaceExplicit('', value);\n                return;\n            }\n            else if (namespace.length > 0) {\n                prefix = this.lookupPrefix(namespace);\n            }\n        }\n        else {\n            if (prefix[0] === 'x') {\n                if (prefix === 'xmlns') {\n                    this.skipPushAndWrite(prefix, localName, namespace);\n                    this.pushNamespaceExplicit(localName, value);\n                    return;\n                }\n                else if (prefix === 'xml') {\n                    if (localName === 'space' || localName === 'lang') {\n                        this.skipPushAndWrite(prefix, localName, namespace);\n                        return;\n                    }\n                }\n            }\n            if (namespace.length === 0) {\n                prefix = '';\n            }\n        }\n        if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n            this.pushNamespaceImplicit(prefix, namespace);\n        }\n        this.skipPushAndWrite(prefix, localName, namespace);\n    };\n    XmlWriter.prototype.writeEndAttribute = function () {\n        this.currentState = 'StartElement';\n        this.bufferText += '\"';\n    };\n    XmlWriter.prototype.writeStartElementInternal = function (prefix, localName, namespace) {\n        this.bufferText += '<';\n        if (prefix.length > 0) {\n            this.rawText(prefix);\n            this.bufferText += ':';\n        }\n        this.rawText(localName);\n        var top = this.elementStack.length;\n        this.elementStack.push(new XmlElement());\n        this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);\n        this.pushNamespaceImplicit(prefix, namespace);\n        for (var i = 0; i < this.attributeStack.length; i++) {\n            this.attributeStack[i].destroy();\n        }\n        this.attributeStack = [];\n    };\n    XmlWriter.prototype.writeEndElementInternal = function (prefix, localName) {\n        if (this.contentPos !== this.bufferText.length + 1) {\n            this.bufferText += '</';\n            if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n                this.rawText(prefix);\n                this.bufferText += ':';\n            }\n            this.rawText(localName);\n            this.bufferText += '>';\n        }\n        else {\n            this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);\n            this.bufferText += ' />';\n        }\n    };\n    XmlWriter.prototype.writeStartAttributeInternal = function (prefix, localName, namespaceName) {\n        this.bufferText += ' ';\n        if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n            this.rawText(prefix);\n            this.bufferText += ':';\n        }\n        this.rawText(localName);\n        this.bufferText += '=';\n        this.bufferText += '\"';\n    };\n    XmlWriter.prototype.writeNamespaceDeclaration = function (prefix, namespaceUri) {\n        this.writeStartNamespaceDeclaration(prefix);\n        this.writeStringInternal(namespaceUri, true);\n        this.bufferText += '\"';\n    };\n    XmlWriter.prototype.writeStartNamespaceDeclaration = function (prefix) {\n        if (prefix === undefined || prefix === null || prefix.length === 0) {\n            this.rawText(' xmlns=\\\"');\n        }\n        else {\n            this.rawText(' xmlns:');\n            this.rawText(prefix);\n            this.bufferText += '=';\n            this.bufferText += '\"';\n        }\n    };\n    XmlWriter.prototype.writeStringInternal = function (text, inAttributeValue) {\n        if (text === null || text === undefined) {\n            text = '';\n        }\n        var tempText = '';\n        text = text.replace(/\\&/g, '&amp;');\n        text = text.replace(/\\</g, '&lt;');\n        text = text.replace(/\\>/g, '&gt;');\n        if (inAttributeValue) {\n            text = text.replace(/\\\"/g, '&quot;');\n        }\n        this.bufferText += text;\n        if (!inAttributeValue) {\n            this.contentPos = 0;\n        }\n    };\n    XmlWriter.prototype.startElementContent = function () {\n        var start = this.elementStack[this.elementStack.length - 1].previousTop;\n        for (var i = this.namespaceStack.length - 1; i > start; i--) {\n            if (this.namespaceStack[i].kind === 'NeedToWrite') {\n                this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);\n            }\n        }\n        this.bufferText += '>';\n        this.contentPos = this.bufferText.length + 1;\n    };\n    XmlWriter.prototype.rawText = function (text) {\n        this.bufferText += text;\n    };\n    XmlWriter.prototype.addNamespace = function (prefix, ns, kind) {\n        var top = this.namespaceStack.length;\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[top].set(prefix, ns, kind);\n    };\n    XmlWriter.prototype.lookupPrefix = function (namespace) {\n        for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].namespaceUri === namespace) {\n                return this.namespaceStack[i].prefix;\n            }\n        }\n        return undefined;\n    };\n    XmlWriter.prototype.lookupNamespace = function (prefix) {\n        for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].prefix === prefix) {\n                return this.namespaceStack[i].namespaceUri;\n            }\n        }\n        return undefined;\n    };\n    XmlWriter.prototype.lookupNamespaceIndex = function (prefix) {\n        for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].prefix === prefix) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    XmlWriter.prototype.pushNamespaceImplicit = function (prefix, ns) {\n        var kind;\n        var existingNsIndex = this.lookupNamespaceIndex(prefix);\n        if (existingNsIndex !== -1) {\n            if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n                if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {\n                    throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');\n                }\n                return;\n            }\n            else {\n                if (this.namespaceStack[existingNsIndex].kind === 'Special') {\n                    if (prefix === 'xml') {\n                        if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {\n                            throw new Error('InvalidArgumentException: Xml String');\n                        }\n                        else {\n                            kind = 'Implied';\n                        }\n                    }\n                    else {\n                        throw new Error('InvalidArgumentException: Prefix \"xmlns\" is reserved for use by XML.');\n                    }\n                }\n                else {\n                    kind = (this.namespaceStack[existingNsIndex].namespaceUri === ns) ? 'Implied' : 'NeedToWrite';\n                }\n            }\n        }\n        else {\n            if ((ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml') ||\n                (ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns')) {\n                throw new Error('InvalidArgumentException');\n            }\n            kind = 'NeedToWrite';\n        }\n        this.addNamespace(prefix, ns, kind);\n    };\n    XmlWriter.prototype.pushNamespaceExplicit = function (prefix, ns) {\n        var existingNsIndex = this.lookupNamespaceIndex(prefix);\n        if (existingNsIndex !== -1) {\n            if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n                this.namespaceStack[existingNsIndex].kind = 'Written';\n                return;\n            }\n        }\n        this.addNamespace(prefix, ns, 'Written');\n        return;\n    };\n    XmlWriter.prototype.addAttribute = function (prefix, localName, namespaceName) {\n        var top = this.attributeStack.length;\n        this.attributeStack.push(new XmlAttribute());\n        this.attributeStack[top].set(prefix, localName, namespaceName);\n        for (var i = 0; i < top; i++) {\n            if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {\n                throw new Error('XmlException: duplicate attribute name');\n            }\n        }\n    };\n    XmlWriter.prototype.skipPushAndWrite = function (prefix, localName, namespace) {\n        this.addAttribute(prefix, localName, namespace);\n        this.writeStartAttributeInternal(prefix, localName, namespace);\n    };\n    XmlWriter.prototype.checkName = function (text) {\n        var format = /[ !@#$%^&*()+\\=\\[\\]{};':\"\\\\|,<>\\/?]/;\n        if (format.test(text)) {\n            throw new Error('InvalidArgumentException: invalid name character');\n        }\n    };\n    return XmlWriter;\n}());\nexport { XmlWriter };\n/**\n * class for managing namespace collection\n */\nvar Namespace = /** @class */ (function () {\n    function Namespace() {\n    }\n    /**\n     * set value for current namespace instance\n     * @param {string} prefix namespace's prefix\n     * @param {string} namespaceUri namespace URI\n     * @param {string} kind namespace kind\n     */\n    Namespace.prototype.set = function (prefix, namespaceUri, kind) {\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.kind = kind;\n    };\n    /**\n     * Releases the resources used by Namespace\n     */\n    Namespace.prototype.destroy = function () {\n        this.prefix = undefined;\n        this.namespaceUri = undefined;\n        this.kind = undefined;\n    };\n    return Namespace;\n}());\nexport { Namespace };\n/**\n * class for managing element collection\n */\nvar XmlElement = /** @class */ (function () {\n    function XmlElement() {\n    }\n    /**\n     * set value of current element\n     * @param {string} prefix - element prefix\n     * @param {string} localName - element local name\n     * @param {string} namespaceUri -namespace URI\n     * @param {string} previousTop - previous namespace top\n     */\n    XmlElement.prototype.set = function (prefix, localName, namespaceUri, previousTop) {\n        this.previousTop = previousTop;\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.localName = localName;\n    };\n    /**\n     * Releases the resources used by XmlElement\n     */\n    XmlElement.prototype.destroy = function () {\n        this.previousTop = undefined;\n        this.prefix = undefined;\n        this.localName = undefined;\n        this.namespaceUri = undefined;\n    };\n    return XmlElement;\n}());\nexport { XmlElement };\n/**\n * class for managing attribute collection\n */\nvar XmlAttribute = /** @class */ (function () {\n    function XmlAttribute() {\n    }\n    /**\n     * set value of current attribute\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    XmlAttribute.prototype.set = function (prefix, localName, namespaceUri) {\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.localName = localName;\n    };\n    /**\n     * get whether the attribute is duplicate or not\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    XmlAttribute.prototype.isDuplicate = function (prefix, localName, namespaceUri) {\n        return ((this.localName === localName) && ((this.prefix === prefix) || (this.namespaceUri === namespaceUri)));\n    };\n    /**\n     * Releases the resources used by XmlAttribute\n     */\n    XmlAttribute.prototype.destroy = function () {\n        this.prefix = undefined;\n        this.namespaceUri = undefined;\n        this.localName = undefined;\n    };\n    return XmlAttribute;\n}());\nexport { XmlAttribute };\n","import { Encoding, validateNullOrUndefined } from './encoding';\nimport { Save } from './save';\n/**\n * StreamWriter class contains the implementation for writing characters to a file in a particular encoding\n * ```typescript\n * let writer = new StreamWriter();\n * writer.write('Hello World');\n * writer.save('Sample.txt');\n * writer.dispose();\n * ```\n */\nvar StreamWriter = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the StreamWriter class by using the specified encoding.\n     * @param  {Encoding} encoding?- The character encoding to use.\n     */\n    function StreamWriter(encoding) {\n        this.bufferBlob = new Blob(['']);\n        this.bufferText = '';\n        this.init(encoding);\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(StreamWriter.prototype, \"buffer\", {\n        /**\n         * Gets the content written to the StreamWriter as Blob.\n         * @returns Blob\n         */\n        get: function () {\n            this.flush();\n            return this.bufferBlob;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StreamWriter.prototype, \"encoding\", {\n        /**\n         * Gets the encoding.\n         * @returns Encoding\n         */\n        get: function () {\n            return this.enc;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StreamWriter.prototype.init = function (encoding) {\n        if (encoding === null || encoding === undefined) {\n            this.enc = new Encoding(false);\n            this.enc.type = 'Utf8';\n        }\n        else {\n            this.enc = encoding;\n            this.setBomByte();\n        }\n    };\n    /**\n     * Private method to set Byte Order Mark(BOM) value based on EncodingType\n     */\n    StreamWriter.prototype.setBomByte = function () {\n        if (this.encoding.includeBom) {\n            switch (this.encoding.type) {\n                case 'Unicode':\n                    var arrayUnicode = new ArrayBuffer(2);\n                    var uint8 = new Uint8Array(arrayUnicode);\n                    uint8[0] = 255;\n                    uint8[1] = 254;\n                    this.bufferBlob = new Blob([arrayUnicode]);\n                    break;\n                case 'Utf8':\n                    var arrayUtf8 = new ArrayBuffer(3);\n                    var utf8 = new Uint8Array(arrayUtf8);\n                    utf8[0] = 239;\n                    utf8[1] = 187;\n                    utf8[2] = 191;\n                    this.bufferBlob = new Blob([arrayUtf8]);\n                    break;\n                default:\n                    this.bufferBlob = new Blob(['']);\n                    break;\n            }\n        }\n    };\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName - The file name to save\n     * @returns {void}\n     */\n    StreamWriter.prototype.save = function (fileName) {\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    };\n    /**\n     * Writes the specified string.\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written.\n     * @returns {void}\n     */\n    StreamWriter.prototype.write = function (value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText += value;\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    };\n    StreamWriter.prototype.flush = function () {\n        if (this.bufferText === undefined || this.bufferText === null || this.bufferText.length === 0) {\n            return;\n        }\n        var bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);\n        this.bufferText = '';\n        this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);\n    };\n    /**\n     * Writes the specified string followed by a line terminator\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written\n     * @returns {void}\n     */\n    StreamWriter.prototype.writeLine = function (value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText = this.bufferText + value + '\\r\\n';\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    };\n    /**\n     * Releases the resources used by the StreamWriter\n     * @returns {void}\n     */\n    StreamWriter.prototype.destroy = function () {\n        this.bufferBlob = undefined;\n        this.bufferText = undefined;\n        if (this.enc instanceof Encoding) {\n            this.enc.destroy();\n        }\n        this.enc = undefined;\n    };\n    return StreamWriter;\n}());\nexport { StreamWriter };\n","import { Encoding } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\nvar arrLiteralCodes = new Int16Array(286);\nvar arrLiteralLengths = new Uint8Array(286);\nvar arrDistanceCodes = new Int16Array(30);\nvar arrDistanceLengths = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nvar CompressedStreamWriter = /** @class */ (function () {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    function CompressedStreamWriter(noWrap) {\n        this.pendingBuffer = new Uint8Array(1 << 16);\n        this.pendingBufLength = 0;\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.currentHash = 0;\n        this.matchStart = 0;\n        this.matchLength = 0;\n        this.matchPrevAvail = false;\n        this.blockStart = 0;\n        this.stringStart = 0;\n        this.lookAhead = 0;\n        this.totalBytesIn = 0;\n        this.inputOffset = 0;\n        this.inputEnd = 0;\n        this.windowSize = 1 << 15;\n        this.windowMask = this.windowSize - 1;\n        this.hashSize = 1 << 15;\n        this.hashMask = this.hashSize - 1;\n        this.hashShift = Math.floor((15 + 3 - 1) / 3);\n        this.maxDist = this.windowSize - 262;\n        this.checkSum = 1;\n        this.noWrap = false;\n        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n        this.arrDistances = new Uint16Array((1 << 14));\n        this.arrLiterals = new Uint8Array((1 << 14));\n        this.stream = [];\n        this.dataWindow = new Uint8Array(2 * this.windowSize);\n        this.hashHead = new Int16Array(this.hashSize);\n        this.hashPrevious = new Int16Array(this.windowSize);\n        this.blockStart = this.stringStart = 1;\n        this.noWrap = noWrap;\n        if (!noWrap) {\n            this.writeZLibHeader();\n        }\n    }\n    Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n        /**\n         * get compressed data\n         */\n        get: function () {\n            return this.stream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n        get: function () {\n            var compressedString = '';\n            if (this.stream !== undefined) {\n                for (var i = 0; i < this.stream.length; i++) {\n                    compressedString += String.fromCharCode.apply(null, this.stream[i]);\n                }\n            }\n            return compressedString;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.write = function (data, offset, length) {\n        if (data === undefined || data === null) {\n            throw new Error('ArgumentException: data cannot null or undefined');\n        }\n        var end = offset + length;\n        if (0 > offset || offset > end || end > data.length) {\n            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n        }\n        if (typeof data === 'string') {\n            var encode = new Encoding(false);\n            encode.type = 'Utf8';\n            data = new Uint8Array(encode.getBytes(data, 0, data.length));\n            end = offset + data.length;\n        }\n        this.inputBuffer = data;\n        this.inputOffset = offset;\n        this.inputEnd = end;\n        if (!this.noWrap) {\n            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n        }\n        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n            this.pendingBufferFlush();\n            this.compressData(false);\n        }\n    };\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n    CompressedStreamWriter.prototype.writeZLibHeader = function () {\n        /* Initialize header.*/\n        var headerDate = (8 + (7 << 4)) << 8;\n        /* Save compression level.*/\n        headerDate |= ((5 >> 2) & 3) << 6;\n        /* Align header.*/\n        headerDate += 31 - (headerDate % 31);\n        /* Write header to stream.*/\n        this.pendingBufferWriteShortBytes(headerDate);\n    };\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n        this.pendingBuffer[this.pendingBufLength++] = s;\n    };\n    CompressedStreamWriter.prototype.compressData = function (finish) {\n        var success;\n        do {\n            this.fillWindow();\n            var canFlush = (finish && this.inputEnd === this.inputOffset);\n            success = this.compressSlow(canFlush, finish);\n        } while (this.pendingBufLength === 0 && success);\n        return success;\n    };\n    CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n        if (this.lookAhead < 262 && !flush) {\n            return false;\n        }\n        while (this.lookAhead >= 262 || flush) {\n            if (this.lookAhead === 0) {\n                return this.lookAheadCompleted(finish);\n            }\n            if (this.stringStart >= 2 * this.windowSize - 262) {\n                this.slideWindow();\n            }\n            var prevMatch = this.matchStart;\n            var prevLen = this.matchLength;\n            if (this.lookAhead >= 3) {\n                this.discardMatch();\n            }\n            if (prevLen >= 3 && this.matchLength <= prevLen) {\n                prevLen = this.matchPreviousBest(prevMatch, prevLen);\n            }\n            else {\n                this.matchPreviousAvailable();\n            }\n            if (this.bufferPosition >= (1 << 14)) {\n                return this.huffmanIsFull(finish);\n            }\n        }\n        return true;\n    };\n    CompressedStreamWriter.prototype.discardMatch = function () {\n        var hashHead = this.insertString();\n        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {\n                this.matchLength = 3 - 1;\n            }\n        }\n    };\n    CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = true;\n        this.stringStart++;\n        this.lookAhead--;\n    };\n    CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n        prevLen -= 2;\n        do {\n            this.stringStart++;\n            this.lookAhead--;\n            if (this.lookAhead >= 3) {\n                this.insertString();\n            }\n        } while (--prevLen > 0);\n        this.stringStart++;\n        this.lookAhead--;\n        this.matchPrevAvail = false;\n        this.matchLength = 3 - 1;\n        return prevLen;\n    };\n    CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = false;\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n        this.blockStart = this.stringStart;\n        return false;\n    };\n    CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n        var len = this.stringStart - this.blockStart;\n        if (this.matchPrevAvail) {\n            len--;\n        }\n        var lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n        this.blockStart += len;\n        return !lastBlock;\n    };\n    CompressedStreamWriter.prototype.fillWindow = function () {\n        if (this.stringStart >= this.windowSize + this.maxDist) {\n            this.slideWindow();\n        }\n        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n            var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n            if (more > this.inputEnd - this.inputOffset) {\n                more = this.inputEnd - this.inputOffset;\n            }\n            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n            this.inputOffset += more;\n            this.totalBytesIn += more;\n            this.lookAhead += more;\n        }\n        if (this.lookAhead >= 3) {\n            this.updateHash();\n        }\n    };\n    CompressedStreamWriter.prototype.slideWindow = function () {\n        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n        this.matchStart -= this.windowSize;\n        this.stringStart -= this.windowSize;\n        this.blockStart -= this.windowSize;\n        for (var i = 0; i < this.hashSize; ++i) {\n            var m = this.hashHead[i] & 0xffff;\n            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));\n        }\n        for (var i = 0; i < this.windowSize; i++) {\n            var m = this.hashPrevious[i] & 0xffff;\n            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);\n        }\n    };\n    CompressedStreamWriter.prototype.insertString = function () {\n        var match;\n        var hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n        this.hashHead[hash] = this.stringStart;\n        this.currentHash = hash;\n        return match & 0xffff;\n    };\n    CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n        var chainLen = 4096;\n        var niceLen = 258;\n        var scan = this.stringStart;\n        var match;\n        var bestEnd = this.stringStart + this.matchLength;\n        var bestLength = Math.max(this.matchLength, 3 - 1);\n        var limit = Math.max(this.stringStart - this.maxDist, 0);\n        var stringEnd = this.stringStart + 258 - 1;\n        var scanEnd1 = this.dataWindow[bestEnd - 1];\n        var scanEnd = this.dataWindow[bestEnd];\n        var data = this.dataWindow;\n        if (bestLength >= 32) {\n            chainLen >>= 2;\n        }\n        if (niceLen > this.lookAhead) {\n            niceLen = this.lookAhead;\n        }\n        do {\n            if (data[curMatch + bestLength] !== scanEnd ||\n                data[curMatch + bestLength - 1] !== scanEnd1 ||\n                data[curMatch] !== data[scan] ||\n                data[curMatch + 1] !== data[scan + 1]) {\n                continue;\n            }\n            match = curMatch + 2;\n            scan += 2;\n            /* tslint:disable */\n            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n                /* tslint:disable */\n            }\n            if (scan > bestEnd) {\n                this.matchStart = curMatch;\n                bestEnd = scan;\n                bestLength = scan - this.stringStart;\n                if (bestLength >= niceLen) {\n                    break;\n                }\n                scanEnd1 = data[bestEnd - 1];\n                scanEnd = data[bestEnd];\n            }\n            scan = this.stringStart;\n        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);\n        this.matchLength = Math.min(bestLength, this.lookAhead);\n        return this.matchLength >= 3;\n    };\n    CompressedStreamWriter.prototype.updateHash = function () {\n        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];\n    };\n    CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n        this.arrDistances[this.bufferPosition] = 0;\n        this.arrLiterals[this.bufferPosition++] = literal;\n        this.treeLiteral.codeFrequencies[literal]++;\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n        this.arrDistances[this.bufferPosition] = dist;\n        this.arrLiterals[this.bufferPosition++] = (len - 3);\n        var lc = this.huffmanLengthCode(len - 3);\n        this.treeLiteral.codeFrequencies[lc]++;\n        if (lc >= 265 && lc < 285) {\n            this.extraBits += Math.floor((lc - 261) / 4);\n        }\n        var dc = this.huffmanDistanceCode(dist - 1);\n        this.treeDistances.codeFrequencies[dc]++;\n        if (dc >= 4) {\n            this.extraBits += Math.floor((dc / 2 - 1));\n        }\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.treeLiteral.codeFrequencies[256]++;\n        this.treeLiteral.buildTree();\n        this.treeDistances.buildTree();\n        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n        this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n        this.treeCodeLengths.buildTree();\n        var blTreeCodes = 4;\n        for (var i = 18; i > blTreeCodes; i--) {\n            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n                blTreeCodes = i + 1;\n            }\n        }\n        var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +\n            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n        var static_len = this.extraBits;\n        for (var i = 0; i < 286; i++) {\n            static_len += this.treeLiteral.codeFrequencies[i] * arrLiteralLengths[i];\n        }\n        for (var i = 0; i < 30; i++) {\n            static_len += this.treeDistances.codeFrequencies[i] * arrDistanceLengths[i];\n        }\n        if (opt_len >= static_len) {\n            // Force static trees.\n            opt_len = static_len;\n        }\n        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n        }\n        else if (opt_len == static_len) {\n            // Encode with static tree.\n            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n            this.treeLiteral.setStaticCodes(arrLiteralCodes, arrLiteralLengths);\n            this.treeDistances.setStaticCodes(arrDistanceCodes, arrDistanceLengths);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n        else {\n            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n            this.huffmanSendAllTrees(blTreeCodes);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n    };\n    CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n        this.pendingBufferAlignToByte();\n        this.pendingBufferWriteShort(storedLength);\n        this.pendingBufferWriteShort(~storedLength);\n        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n        this.huffmanReset();\n    };\n    CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n        if (len === 255) {\n            return 285;\n        }\n        var code = 257;\n        while (len >= 8) {\n            code += 4;\n            len >>= 1;\n        }\n        return code + len;\n    };\n    CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n        var code = 0;\n        while (distance >= 4) {\n            code += 2;\n            distance >>= 1;\n        }\n        return code + distance;\n    };\n    CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n        this.treeCodeLengths.buildCodes();\n        this.treeLiteral.buildCodes();\n        this.treeDistances.buildCodes();\n        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n        this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n        for (var rank = 0; rank < blTreeCodes; rank++) {\n            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n        }\n        this.treeLiteral.writeTree(this.treeCodeLengths);\n        this.treeDistances.writeTree(this.treeCodeLengths);\n    };\n    CompressedStreamWriter.prototype.huffmanReset = function () {\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.treeLiteral.reset();\n        this.treeDistances.reset();\n        this.treeCodeLengths.reset();\n    };\n    CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n        for (var i = 0; i < this.bufferPosition; i++) {\n            var literalLen = this.arrLiterals[i] & 255;\n            var dist = this.arrDistances[i];\n            if (dist-- !== 0) {\n                var lc = this.huffmanLengthCode(literalLen);\n                this.treeLiteral.writeCodeToStream(lc);\n                var bits = Math.floor((lc - 261) / 4);\n                if (bits > 0 && bits <= 5) {\n                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);\n                }\n                var dc = this.huffmanDistanceCode(dist);\n                this.treeDistances.writeCodeToStream(dc);\n                bits = Math.floor(dc / 2 - 1);\n                if (bits > 0) {\n                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);\n                }\n            }\n            else {\n                this.treeLiteral.writeCodeToStream(literalLen);\n            }\n        }\n        this.treeLiteral.writeCodeToStream(256);\n    };\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n        var uint = new Uint32Array(1);\n        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);\n        this.pendingBufCache = uint[0];\n        this.pendingBufBitsInCache += count;\n        this.pendingBufferFlushBits();\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n        this.pendingBufferFlushBits();\n        if (this.pendingBufLength > 0) {\n            var array = new Uint8Array(this.pendingBufLength);\n            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n            this.stream.push(array);\n        }\n        this.pendingBufLength = 0;\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n        var result = 0;\n        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n            this.pendingBufCache >>= 8;\n            this.pendingBufBitsInCache -= 8;\n            result++;\n        }\n        return result;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n        var array = data.subarray(offset, offset + length);\n        this.pendingBuffer.set(array, this.pendingBufLength);\n        this.pendingBufLength += length;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s;\n        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);\n    };\n    CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n        if (this.pendingBufBitsInCache > 0) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        }\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n    };\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.close = function () {\n        do {\n            this.pendingBufferFlush(true);\n            if (!this.compressData(true)) {\n                this.pendingBufferFlush(true);\n                this.pendingBufferAlignToByte();\n                if (!this.noWrap) {\n                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n                }\n                this.pendingBufferFlush(true);\n            }\n        } while (!(this.inputEnd === this.inputOffset) ||\n            !(this.pendingBufLength === 0));\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.destroy = function () {\n        this.stream = [];\n        this.stream = undefined;\n        this.pendingBuffer = undefined;\n        this.treeLiteral = undefined;\n        this.treeDistances = undefined;\n        this.treeCodeLengths = undefined;\n        this.arrLiterals = undefined;\n        this.arrDistances = undefined;\n        this.hashHead = undefined;\n        this.hashPrevious = undefined;\n        this.dataWindow = undefined;\n        this.inputBuffer = undefined;\n        this.pendingBufLength = undefined;\n        this.pendingBufCache = undefined;\n        this.pendingBufBitsInCache = undefined;\n        this.bufferPosition = undefined;\n        this.extraBits = undefined;\n        this.currentHash = undefined;\n        this.matchStart = undefined;\n        this.matchLength = undefined;\n        this.matchPrevAvail = undefined;\n        this.blockStart = undefined;\n        this.stringStart = undefined;\n        this.lookAhead = undefined;\n        this.totalBytesIn = undefined;\n        this.inputOffset = undefined;\n        this.inputEnd = undefined;\n        this.windowSize = undefined;\n        this.windowMask = undefined;\n        this.hashSize = undefined;\n        this.hashMask = undefined;\n        this.hashShift = undefined;\n        this.maxDist = undefined;\n        this.checkSum = undefined;\n        this.noWrap = undefined;\n    };\n    return CompressedStreamWriter;\n}());\nexport { CompressedStreamWriter };\n/**\n * represent the Huffman Tree\n */\nvar CompressorHuffmanTree = /** @class */ (function () {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n        this.writer = writer;\n        this.codeMinCount = minCodes;\n        this.maxLength = maxLength;\n        this.codeFrequency = new Uint16Array(elementCount);\n        this.lengthCount = new Int32Array(maxLength);\n    }\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n        get: function () {\n            return this.codeCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n        get: function () {\n            return this.codeLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n        get: function () {\n            return this.codeFrequency;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n        var temp = new Int16Array(codes.length);\n        temp.set(codes, 0);\n        this.codes = temp;\n        var lengthTemp = new Uint8Array(lengths.length);\n        lengthTemp.set(lengths, 0);\n        this.codeLength = lengthTemp;\n    };\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.reset = function () {\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            this.codeFrequency[i] = 0;\n        }\n        this.codes = undefined;\n        this.codeLength = undefined;\n    };\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    };\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildCodes = function () {\n        var nextCode = new Int32Array(this.maxLength);\n        this.codes = new Int16Array(this.codeCount);\n        var code = 0;\n        for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n            nextCode[bitsCount] = code;\n            code += this.lengthCount[bitsCount] << (15 - bitsCount);\n        }\n        for (var i = 0; i < this.codeCount; i++) {\n            var bits = this.codeLength[i];\n            if (bits > 0) {\n                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n                nextCode[bits - 1] += 1 << (16 - bits);\n            }\n        }\n    };\n    CompressorHuffmanTree.bitReverse = function (value) {\n        return (CompressorHuffmanTree.reverseBits[value & 15] << 12\n            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8\n            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4\n            | CompressorHuffmanTree.reverseBits[value >> 12]);\n    };\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    CompressorHuffmanTree.prototype.getEncodedLength = function () {\n        var len = 0;\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            len += this.codeFrequency[i] * this.codeLength[i];\n        }\n        return len;\n    };\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n        var maxCount;\n        var minCount;\n        var count;\n        var curLen = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            count = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxCount = 138;\n                minCount = 3;\n            }\n            else {\n                maxCount = 6;\n                minCount = 3;\n                if (curLen !== nextLen) {\n                    blTree.codeFrequency[nextLen]++;\n                    count = 0;\n                }\n            }\n            curLen = nextLen;\n            i++;\n            while (i < this.codeCount && curLen === this.codeLength[i]) {\n                i++;\n                if (++count >= maxCount) {\n                    break;\n                }\n            }\n            if (count < minCount) {\n                blTree.codeFrequency[curLen] += count;\n            }\n            else if (curLen !== 0) {\n                blTree.codeFrequency[16]++;\n            }\n            else if (count <= 10) {\n                blTree.codeFrequency[17]++;\n            }\n            else {\n                blTree.codeFrequency[18]++;\n            }\n        }\n    };\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n        var maxRepeatCount;\n        var minRepeatCount;\n        var currentRepeatCount;\n        var currentCodeLength = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            currentRepeatCount = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxRepeatCount = 138;\n                minRepeatCount = 3;\n            }\n            else {\n                maxRepeatCount = 6;\n                minRepeatCount = 3;\n                if (currentCodeLength !== nextLen) {\n                    blTree.writeCodeToStream(nextLen);\n                    currentRepeatCount = 0;\n                }\n            }\n            currentCodeLength = nextLen;\n            i++;\n            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n                i++;\n                if (++currentRepeatCount >= maxRepeatCount) {\n                    break;\n                }\n            }\n            if (currentRepeatCount < minRepeatCount) {\n                while (currentRepeatCount-- > 0) {\n                    blTree.writeCodeToStream(currentCodeLength);\n                }\n            }\n            else if (currentCodeLength !== 0) {\n                blTree.writeCodeToStream(16);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n            }\n            else if (currentRepeatCount <= 10) {\n                blTree.writeCodeToStream(17);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n            }\n            else {\n                blTree.writeCodeToStream(18);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n            }\n        }\n    };\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildTree = function () {\n        var codesCount = this.codeFrequency.length;\n        var arrTree = new Int32Array(codesCount);\n        var treeLength = 0;\n        var maxCount = 0;\n        for (var n = 0; n < codesCount; n++) {\n            var freq = this.codeFrequency[n];\n            if (freq !== 0) {\n                var pos = treeLength++;\n                var pPos = 0;\n                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n                    arrTree[pos] = arrTree[pPos];\n                    pos = pPos;\n                }\n                arrTree[pos] = n;\n                maxCount = n;\n            }\n        }\n        while (treeLength < 2) {\n            arrTree[treeLength++] =\n                (maxCount < 2) ? ++maxCount : 0;\n        }\n        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n        var leafsCount = treeLength;\n        var nodesCount = leafsCount;\n        var child = new Int32Array(4 * treeLength - 2);\n        var values = new Int32Array(2 * treeLength - 1);\n        for (var i = 0; i < treeLength; i++) {\n            var node = arrTree[i];\n            var iIndex = 2 * i;\n            child[iIndex] = node;\n            child[iIndex + 1] = -1;\n            values[i] = (this.codeFrequency[node] << 8);\n            arrTree[i] = i;\n        }\n        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n        this.buildLength(child);\n    };\n    CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n        do {\n            var first = arrTree[0];\n            var last = arrTree[--treeLength];\n            var lastVal = values[last];\n            var pPos = 0;\n            var path = 1;\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            }\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n            var second = arrTree[0];\n            last = nodesCount++;\n            child[2 * last] = first;\n            child[2 * last + 1] = second;\n            var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n            values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n            pPos = 0;\n            path = 1;\n            /* tslint:disable */\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            } /* tslint:disable */\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n        } while (treeLength > 1);\n    };\n    CompressorHuffmanTree.prototype.buildLength = function (child) {\n        this.codeLength = new Uint8Array(this.codeFrequency.length);\n        var numNodes = Math.floor(child.length / 2);\n        var numLeafs = Math.floor((numNodes + 1) / 2);\n        var overflow = 0;\n        for (var i = 0; i < this.maxLength; i++) {\n            this.lengthCount[i] = 0;\n        }\n        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n        if (overflow === 0) {\n            return;\n        }\n        var iIncreasableLength = this.maxLength - 1;\n        do {\n            while (this.lengthCount[--iIncreasableLength] === 0) {\n                /* tslint:disable */\n            }\n            do {\n                this.lengthCount[iIncreasableLength]--;\n                this.lengthCount[++iIncreasableLength]++;\n                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));\n            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n        } while (overflow > 0);\n        this.recreateTree(child, overflow, numLeafs);\n    };\n    CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n        this.lengthCount[this.maxLength - 1] += overflow;\n        this.lengthCount[this.maxLength - 2] -= overflow;\n        var nodePtr = 2 * numLeafs;\n        for (var bits = this.maxLength; bits !== 0; bits--) {\n            var n = this.lengthCount[bits - 1];\n            while (n > 0) {\n                var childPtr = 2 * child[nodePtr++];\n                if (child[childPtr + 1] === -1) {\n                    this.codeLength[child[childPtr]] = bits;\n                    n--;\n                }\n            }\n        }\n    };\n    CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n        var lengths = new Int32Array(numNodes);\n        lengths[numNodes - 1] = 0;\n        for (var i = numNodes - 1; i >= 0; i--) {\n            var childIndex = 2 * i + 1;\n            if (child[childIndex] !== -1) {\n                var bitLength = lengths[i] + 1;\n                if (bitLength > this.maxLength) {\n                    bitLength = this.maxLength;\n                    overflow++;\n                }\n                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n            }\n            else {\n                var bitLength = lengths[i];\n                this.lengthCount[bitLength - 1]++;\n                this.codeLength[child[childIndex - 1]] = lengths[i];\n            }\n        }\n        return overflow;\n    };\n    CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return CompressorHuffmanTree;\n}());\nexport { CompressorHuffmanTree };\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nvar ChecksumCalculator = /** @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n        var uint = new Uint32Array(1);\n        uint[0] = checksum;\n        var checksum_uint = uint[0];\n        var s1 = uint[0] = checksum_uint & 65535;\n        var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n        while (length > 0) {\n            var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (uint[0] = (buffer[offset++] & 255));\n                s2 = s2 + s1;\n            }\n            s1 %= ChecksumCalculator.checksumBase;\n            s2 %= ChecksumCalculator.checksumBase;\n        }\n        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;\n        return checksum_uint;\n    };\n    ChecksumCalculator.checkSumBitOffset = 16;\n    ChecksumCalculator.checksumBase = 65521;\n    ChecksumCalculator.checksumIterationCount = 3800;\n    return ChecksumCalculator;\n}());\nexport { ChecksumCalculator };\n/**\n * Huffman Tree literal calculation\n */\n(function () {\n    var i = 0;\n    while (i < 144) {\n        arrLiteralCodes[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);\n        arrLiteralLengths[i++] = 8;\n    }\n    while (i < 256) {\n        arrLiteralCodes[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);\n        arrLiteralLengths[i++] = 9;\n    }\n    while (i < 280) {\n        arrLiteralCodes[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);\n        arrLiteralLengths[i++] = 7;\n    }\n    while (i < 286) {\n        arrLiteralCodes[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);\n        arrLiteralLengths[i++] = 8;\n    }\n    for (i = 0; i < 30; i++) {\n        arrDistanceCodes[i] = CompressorHuffmanTree.bitReverse(i << 11);\n        arrDistanceLengths[i] = 5;\n    }\n})();\n","import { CompressedStreamWriter } from './compression-writer';\nimport { Save } from '@syncfusion/ej2-file-utils';\nvar crc32Table = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nvar ZipArchive = /** @class */ (function () {\n    /**\n     * constructor for creating ZipArchive instance\n     */\n    function ZipArchive() {\n        this.files = [];\n        this.level = 'Normal';\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n        /**\n         * gets compression level\n         */\n        get: function () {\n            return this.level;\n        },\n        /**\n         * sets compression level\n         */\n        set: function (level) {\n            this.level = level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"length\", {\n        /**\n         * gets items count\n         */\n        get: function () {\n            if (this.files === undefined) {\n                return 0;\n            }\n            return this.files.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * add new item to archive\n     * @param {ZipArchiveItem} item - item to be added\n     * @returns {void}\n     */\n    ZipArchive.prototype.addItem = function (item) {\n        if (item === null || item === undefined) {\n            throw new Error('ArgumentException: item cannot be null or undefined');\n        }\n        for (var i = 0; i < this.files.length; i++) {\n            var file = this.files[i];\n            if (file instanceof ZipArchiveItem) {\n                if (file.name === item.name) {\n                    throw new Error('item with same name already exist');\n                }\n            }\n        }\n        this.files.push(item);\n    };\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n    ZipArchive.prototype.addDirectory = function (directoryName) {\n        if (directoryName === null || directoryName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (directoryName.length === 0) {\n            throw new Error('ArgumentException: string cannot be empty');\n        }\n        if (directoryName.slice(-1) !== '/') {\n            directoryName += '/';\n        }\n        if (this.files.indexOf(directoryName) !== -1) {\n            throw new Error('item with same name already exist');\n        }\n        this.files.push(directoryName);\n    };\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n    ZipArchive.prototype.getItem = function (index) {\n        if (index >= 0 && index < this.files.length) {\n            return this.files[index];\n        }\n        return undefined;\n    };\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n    ZipArchive.prototype.contains = function (item) {\n        return this.files.indexOf(item) !== -1 ? true : false;\n    };\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n    ZipArchive.prototype.save = function (fileName) {\n        if (fileName === null || fileName === undefined || fileName.length === 0) {\n            throw new Error('ArgumentException: fileName cannot be null or undefined');\n        }\n        if (this.files.length === 0) {\n            throw new Error('InvalidOperation');\n        }\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal(fileName, false).then(function () {\n                resolve(zipArchive);\n            });\n        });\n    };\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n    ZipArchive.prototype.saveAsBlob = function () {\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal('', true).then(function (blob) {\n                resolve(blob);\n            });\n        });\n    };\n    ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n        var _this = this;\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            var zipData = [];\n            var dirLength = 0;\n            for (var i = 0; i < zipArchive.files.length; i++) {\n                var compressedObject = _this.getCompressedData(_this.files[i]);\n                compressedObject.then(function (data) {\n                    dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n                    if (zipData.length === zipArchive.files.length) {\n                        var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n                        resolve(blob);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchive.prototype.destroy = function () {\n        if (this.files !== undefined && this.files.length > 0) {\n            for (var i = 0; i < this.files.length; i++) {\n                var file = this.files[i];\n                if (file instanceof ZipArchiveItem) {\n                    file.destroy();\n                }\n                file = undefined;\n            }\n            this.files = [];\n        }\n        this.files = undefined;\n        this.level = undefined;\n    };\n    ZipArchive.prototype.getCompressedData = function (item) {\n        var zipArchive = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (item instanceof ZipArchiveItem) {\n                var reader_1 = new FileReader();\n                reader_1.onload = function () {\n                    var input = new Uint8Array(reader_1.result);\n                    var data = {\n                        fileName: item.name, crc32Value: 0, compressedData: [],\n                        compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,\n                        isDirectory: false\n                    };\n                    if (zipArchive.level === 'Normal') {\n                        zipArchive.compressData(input, data, crc32Table);\n                        var length_1 = 0;\n                        for (var i = 0; i < data.compressedData.length; i++) {\n                            length_1 += data.compressedData[i].length;\n                        }\n                        data.compressedSize = length_1;\n                        data.compressionType = '\\x08\\x00'; //Deflated = 8\n                    }\n                    else {\n                        data.compressedSize = input.length;\n                        data.crc32Value = zipArchive.calculateCrc32Value(0, input, crc32Table);\n                        data.compressionType = '\\x00\\x00'; // Stored = 0\n                        data.compressedData.push(input);\n                    }\n                    resolve(data);\n                };\n                reader_1.readAsArrayBuffer(item.data);\n            }\n            else {\n                var data = {\n                    fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,\n                    compressionType: '\\x00\\x00', isDirectory: true\n                };\n                resolve(data);\n            }\n        });\n        return promise;\n    };\n    ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n        var compressor = new CompressedStreamWriter(true);\n        var currentIndex = 0;\n        var nextIndex = 0;\n        do {\n            if (currentIndex >= input.length) {\n                compressor.close();\n                break;\n            }\n            nextIndex = Math.min(input.length, currentIndex + 16384);\n            var subArray = input.subarray(currentIndex, nextIndex);\n            data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n            compressor.write(subArray, 0, nextIndex - currentIndex);\n            currentIndex = nextIndex;\n        } while (currentIndex <= input.length);\n        data.compressedData = compressor.compressedData;\n        compressor.destroy();\n    };\n    ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n        var extFileAttr = 0;\n        var date = new Date();\n        if (isDirectory) {\n            extFileAttr = extFileAttr | 0x00010; // directory flag\n        }\n        extFileAttr = extFileAttr | (0 & 0x3F);\n        var header = this.writeHeader(data, date);\n        var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n        var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n        zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });\n        return dirLength + localHeader.length + data.compressedSize;\n    };\n    ZipArchive.prototype.writeHeader = function (data, date) {\n        var zipHeader = '';\n        zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n        zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n        zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n        zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n        zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n        zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n        zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n        zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n        zipHeader += this.getBytes(0, 2); // extra field length\n        return zipHeader;\n    };\n    ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n        var cenDirLen = 0;\n        var buffer = [];\n        for (var i = 0; i < zipData.length; i++) {\n            var item = zipData[i];\n            cenDirLen += item.centralDir.length;\n            buffer.push(this.getArrayBuffer(item.localHeader));\n            while (item.compressedData.compressedData.length) {\n                buffer.push(item.compressedData.compressedData.shift().buffer);\n            }\n        }\n        for (var i = 0; i < zipData.length; i++) {\n            buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n        }\n        buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n        var blob = new Blob(buffer, { type: 'application/zip' });\n        if (!skipFileSave) {\n            Save.save(fileName, blob);\n        }\n        return blob;\n    };\n    ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n        var directoryHeader = 'PK\\x01\\x02' +\n            this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n            this.getBytes(0, 2) + // comment length\n            '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n            this.getBytes(externalFileAttribute, 4) + // external file attributes\n            this.getBytes(offset, 4) + // local fileHeader relative offset\n            data.fileName;\n        return directoryHeader;\n    };\n    ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n        var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' +\n            this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +\n            this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +\n            this.getBytes(0, 2);\n        return dirEnd;\n    };\n    ZipArchive.prototype.getArrayBuffer = function (input) {\n        var a = new Uint8Array(input.length);\n        for (var j = 0; j < input.length; ++j) {\n            a[j] = input.charCodeAt(j) & 0xFF;\n        }\n        return a.buffer;\n    };\n    ZipArchive.prototype.getBytes = function (value, offset) {\n        var bytes = '';\n        for (var i = 0; i < offset; i++) {\n            bytes += String.fromCharCode(value & 0xff);\n            value = value >>> 8;\n        }\n        return bytes;\n    };\n    ZipArchive.prototype.getModifiedTime = function (date) {\n        var modTime = date.getHours();\n        modTime = modTime << 6;\n        modTime = modTime | date.getMinutes();\n        modTime = modTime << 5;\n        return modTime = modTime | date.getSeconds() / 2;\n    };\n    ZipArchive.prototype.getModifiedDate = function (date) {\n        var modiDate = date.getFullYear() - 1980;\n        modiDate = modiDate << 4;\n        modiDate = modiDate | (date.getMonth() + 1);\n        modiDate = modiDate << 5;\n        return modiDate = modiDate | date.getDate();\n    };\n    ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n        crc32Value ^= -1;\n        for (var i = 0; i < input.length; i++) {\n            crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n        }\n        return (crc32Value ^ (-1));\n    };\n    return ZipArchive;\n}());\nexport { ZipArchive };\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nvar ZipArchiveItem = /** @class */ (function () {\n    /**\n     * constructor for creating {ZipArchiveItem} instance\n     * @param {Blob|ArrayBuffer} data file data\n     * @param {itemName} itemName absolute file path\n     */\n    function ZipArchiveItem(data, itemName) {\n        if (data === null || data === undefined) {\n            throw new Error('ArgumentException: data cannot be null or undefined');\n        }\n        if (itemName === null || itemName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (itemName.length === 0) {\n            throw new Error('string cannot be empty');\n        }\n        this.data = data;\n        this.name = itemName;\n    }\n    Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n        /**\n         * Get the name of archive item\n         * @returns string\n         */\n        get: function () {\n            return this.fileName;\n        },\n        /**\n         * Set the name of archive item\n         * @param  {string} value\n         */\n        set: function (value) {\n            this.fileName = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchiveItem.prototype.destroy = function () {\n        this.fileName = undefined;\n        this.data = undefined;\n    };\n    return ZipArchiveItem;\n}());\nexport { ZipArchiveItem };\n/**\n * construct cyclic redundancy code table\n */\n(function () {\n    var i;\n    for (var j = 0; j < 256; j++) {\n        i = j;\n        for (var k = 0; k < 8; k++) {\n            i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));\n        }\n        crc32Table[j] = i;\n    }\n})();\n"],"names":["validateNullOrUndefined","value","message","undefined","Error","Save","save","fileName","buffer","extension","substring","lastIndexOf","length","mimeType","this","getMimeType","Blob","type","isMicrosoftBrowser","navigator","msSaveBlob","downloadLink","document","createElementNS","saveInternal","hasDownloadAttribute","download","dataUrl_1","window","URL","createObjectURL","href","event_1","createEvent","initEvent","dispatchEvent","setTimeout","revokeObjectURL","url","open","location","reader_1","FileReader","onloadend","result","readAsDataURL","XmlWriter","contentPos","bufferText","bufferBlob","currentState","namespaceStack","push","Namespace","set","elementStack","XmlElement","attributeStack","Object","defineProperty","prototype","get","flush","enumerable","configurable","writeProcessingInstruction","name","text","checkName","writeStartDocument","writeProcessingInstructionInternal","standalone","rawText","writeEndDocument","writeEndElement","writeStartElement","prefix","localName","namespace","startElementContent","lookupPrefix","lookupNamespace","writeStartElementInternal","top","writeEndElementInternal","splice","previousTop","writeElementString","writeString","writeAttributeString","writeStartAttribute","writeStringInternal","writeEndAttribute","writeInternal","writeRaw","isRawString","destroy","i","replace","writeStartAttributePrefixAndNameSpace","writeStartAttributeSpecialAttribute","skipPushAndWrite","pushNamespaceExplicit","pushNamespaceImplicit","writeStartAttributeInternal","namespaceName","writeNamespaceDeclaration","namespaceUri","writeStartNamespaceDeclaration","inAttributeValue","start","kind","addNamespace","ns","lookupNamespaceIndex","existingNsIndex","addAttribute","XmlAttribute","isDuplicate","test","Encoding","includeBom","emitBOM","encodingType","initBOM","getByteCount","chars","utf8Len","charCodeAt","getByteCountInternal","codePoint","isHighSurrogate","codeUnit","toCodepoint","highCodeUnit","lowCodeUnit","charIndex","charCount","byteCount","isUtf8","charCode","high","low","getBytes","s","RangeError","ArrayBuffer","getBytesOfUtf8Encoding","getBytesOfUnicodeEncoding","getBytesOfAnsiEncoding","getString","bytes","index","count","byteLength","out","byteCal","Uint8Array","getStringOfUtf8Encoding","byteUnicode","Uint16Array","getStringofUnicodeEncoding","j","c","String","fromCharCode","bufview","k","charcode","uint","uint16","byteUni","byte16","apply","StreamWriter","encoding","init","enc","setBomByte","arrayUnicode","uint8","arrayUtf8","utf8","write","bufferArray","writeLine","arrLiteralCodes","Int16Array","arrLiteralLengths","arrDistanceCodes","arrDistanceLengths","CompressedStreamWriter","noWrap","pendingBuffer","pendingBufLength","pendingBufCache","pendingBufBitsInCache","bufferPosition","extraBits","currentHash","matchStart","matchLength","matchPrevAvail","blockStart","stringStart","lookAhead","totalBytesIn","inputOffset","inputEnd","windowSize","windowMask","hashSize","hashMask","hashShift","Math","floor","maxDist","checkSum","treeLiteral","CompressorHuffmanTree","treeDistances","treeCodeLengths","arrDistances","arrLiterals","stream","dataWindow","hashHead","hashPrevious","writeZLibHeader","compressedString","data","offset","end","encode","inputBuffer","ChecksumCalculator","checksumUpdate","pendingBufferFlush","compressData","headerDate","pendingBufferWriteShortBytes","finish","success","fillWindow","canFlush","compressSlow","lookAheadCompleted","slideWindow","prevMatch","prevLen","discardMatch","matchPreviousBest","matchPreviousAvailable","huffmanIsFull","insertString","findLongestMatch","huffmanTallyLit","huffmanTallyDist","huffmanFlushBlock","len","lastBlock","more","subarray","updateHash","m","match","hash","curMatch","chainLen","niceLen","scan","bestEnd","bestLength","max","limit","stringEnd","scanEnd1","scanEnd","min","literal","codeFrequencies","dist","lc","huffmanLengthCode","dc","huffmanDistanceCode","stored","storedOffset","storedLength","buildTree","calculateBLFreq","blTreeCodes","codeLengths","huffCodeLengthOrders","opt_len","getEncodedLength","static_len","huffmanFlushStoredBlock","pendingBufferWriteBits","setStaticCodes","huffmanCompressBlock","huffmanReset","huffmanSendAllTrees","pendingBufferAlignToByte","pendingBufferWriteShort","pendingBufferWriteByteBlock","code","distance","buildCodes","treeLength","rank","writeTree","reset","literalLen","writeCodeToStream","bits","b","Uint32Array","pendingBufferFlushBits","isClose","array","close","writer","elementCount","minCodes","maxLength","codeMinCount","codeFrequency","lengthCount","Int32Array","codeCount","codeLength","codes","lengths","temp","lengthTemp","nextCode","bitsCount","bitReverse","reverseBits","blTree","maxCount","minCount","curLen","nextLen","maxRepeatCount","minRepeatCount","currentRepeatCount","currentCodeLength","codesCount","arrTree","n","freq","pos","pPos","nodesCount","child","values","node","iIndex","constructHuffmanTree","buildLength","first","last","lastVal","path","second","minDepth","numNodes","numLeafs","overflow","calculateOptimalCodeLength","iIncreasableLength","recreateTree","nodePtr","childPtr","childIndex","bitLength","checksum","checksum_uint","s1","s2","checkSumBitOffset","steps","checksumIterationCount","checksumBase","crc32Table","ZipArchive","files","level","addItem","item","file","ZipArchiveItem","addDirectory","directoryName","slice","indexOf","getItem","contains","zipArchive","Promise","resolve","reject","then","saveAsBlob","blob","skipFileSave","_this","zipData","dirLength","getCompressedData","constructZippedObject","isDirectory","writeZippedContent","onload","input","crc32Value","compressedData","compressedSize","uncompressedDataSize","compressionType","length_1","calculateCrc32Value","readAsArrayBuffer","compressor","currentIndex","nextIndex","subArray","zipParts","extFileAttr","date","Date","header","writeHeader","localHeader","centralDir","writeCentralDirectory","zipHeader","getModifiedTime","getModifiedDate","localDirLen","cenDirLen","getArrayBuffer","shift","writeFooter","externalFileAttribute","centralLength","localLength","a","modTime","getHours","getMinutes","getSeconds","modiDate","getFullYear","getMonth","getDate","itemName"],"mappings":"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"}