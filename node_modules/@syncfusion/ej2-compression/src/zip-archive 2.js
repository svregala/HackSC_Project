define(["require", "exports", "./compression-writer", "@syncfusion/ej2-file-utils"], function (require, exports, compression_writer_1, ej2_file_utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var crc32Table = [];
    var ZipArchive = (function () {
        function ZipArchive() {
            this.files = [];
            this.level = 'Normal';
            ej2_file_utils_1.Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);
        }
        Object.defineProperty(ZipArchive.prototype, "compressionLevel", {
            get: function () {
                return this.level;
            },
            set: function (level) {
                this.level = level;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ZipArchive.prototype, "length", {
            get: function () {
                if (this.files === undefined) {
                    return 0;
                }
                return this.files.length;
            },
            enumerable: true,
            configurable: true
        });
        ZipArchive.prototype.addItem = function (item) {
            if (item === null || item === undefined) {
                throw new Error('ArgumentException: item cannot be null or undefined');
            }
            for (var i = 0; i < this.files.length; i++) {
                var file = this.files[i];
                if (file instanceof ZipArchiveItem) {
                    if (file.name === item.name) {
                        throw new Error('item with same name already exist');
                    }
                }
            }
            this.files.push(item);
        };
        ZipArchive.prototype.addDirectory = function (directoryName) {
            if (directoryName === null || directoryName === undefined) {
                throw new Error('ArgumentException: string cannot be null or undefined');
            }
            if (directoryName.length === 0) {
                throw new Error('ArgumentException: string cannot be empty');
            }
            if (directoryName.slice(-1) !== '/') {
                directoryName += '/';
            }
            if (this.files.indexOf(directoryName) !== -1) {
                throw new Error('item with same name already exist');
            }
            this.files.push(directoryName);
        };
        ZipArchive.prototype.getItem = function (index) {
            if (index >= 0 && index < this.files.length) {
                return this.files[index];
            }
            return undefined;
        };
        ZipArchive.prototype.contains = function (item) {
            return this.files.indexOf(item) !== -1 ? true : false;
        };
        ZipArchive.prototype.save = function (fileName) {
            if (fileName === null || fileName === undefined || fileName.length === 0) {
                throw new Error('ArgumentException: fileName cannot be null or undefined');
            }
            if (this.files.length === 0) {
                throw new Error('InvalidOperation');
            }
            var zipArchive = this;
            var promise;
            return promise = new Promise(function (resolve, reject) {
                zipArchive.saveInternal(fileName, false).then(function () {
                    resolve(zipArchive);
                });
            });
        };
        ZipArchive.prototype.saveAsBlob = function () {
            var zipArchive = this;
            var promise;
            return promise = new Promise(function (resolve, reject) {
                zipArchive.saveInternal('', true).then(function (blob) {
                    resolve(blob);
                });
            });
        };
        ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {
            var _this = this;
            var zipArchive = this;
            var promise;
            return promise = new Promise(function (resolve, reject) {
                var zipData = [];
                var dirLength = 0;
                for (var i = 0; i < zipArchive.files.length; i++) {
                    var compressedObject = _this.getCompressedData(_this.files[i]);
                    compressedObject.then(function (data) {
                        dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);
                        if (zipData.length === zipArchive.files.length) {
                            var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);
                            resolve(blob);
                        }
                    });
                }
            });
        };
        ZipArchive.prototype.destroy = function () {
            if (this.files !== undefined && this.files.length > 0) {
                for (var i = 0; i < this.files.length; i++) {
                    var file = this.files[i];
                    if (file instanceof ZipArchiveItem) {
                        file.destroy();
                    }
                    file = undefined;
                }
                this.files = [];
            }
            this.files = undefined;
            this.level = undefined;
        };
        ZipArchive.prototype.getCompressedData = function (item) {
            var zipArchive = this;
            var promise = new Promise(function (resolve, reject) {
                if (item instanceof ZipArchiveItem) {
                    var reader_1 = new FileReader();
                    reader_1.onload = function () {
                        var input = new Uint8Array(reader_1.result);
                        var data = {
                            fileName: item.name, crc32Value: 0, compressedData: [],
                            compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,
                            isDirectory: false
                        };
                        if (zipArchive.level === 'Normal') {
                            zipArchive.compressData(input, data, crc32Table);
                            var length_1 = 0;
                            for (var i = 0; i < data.compressedData.length; i++) {
                                length_1 += data.compressedData[i].length;
                            }
                            data.compressedSize = length_1;
                            data.compressionType = '\x08\x00';
                        }
                        else {
                            data.compressedSize = input.length;
                            data.crc32Value = zipArchive.calculateCrc32Value(0, input, crc32Table);
                            data.compressionType = '\x00\x00';
                            data.compressedData.push(input);
                        }
                        resolve(data);
                    };
                    reader_1.readAsArrayBuffer(item.data);
                }
                else {
                    var data = {
                        fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,
                        compressionType: '\x00\x00', isDirectory: true
                    };
                    resolve(data);
                }
            });
            return promise;
        };
        ZipArchive.prototype.compressData = function (input, data, crc32Table) {
            var compressor = new compression_writer_1.CompressedStreamWriter(true);
            var currentIndex = 0;
            var nextIndex = 0;
            do {
                if (currentIndex >= input.length) {
                    compressor.close();
                    break;
                }
                nextIndex = Math.min(input.length, currentIndex + 16384);
                var subArray = input.subarray(currentIndex, nextIndex);
                data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);
                compressor.write(subArray, 0, nextIndex - currentIndex);
                currentIndex = nextIndex;
            } while (currentIndex <= input.length);
            data.compressedData = compressor.compressedData;
            compressor.destroy();
        };
        ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {
            var extFileAttr = 0;
            var date = new Date();
            if (isDirectory) {
                extFileAttr = extFileAttr | 0x00010;
            }
            extFileAttr = extFileAttr | (0 & 0x3F);
            var header = this.writeHeader(data, date);
            var localHeader = 'PK\x03\x04' + header + data.fileName;
            var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);
            zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });
            return dirLength + localHeader.length + data.compressedSize;
        };
        ZipArchive.prototype.writeHeader = function (data, date) {
            var zipHeader = '';
            zipHeader += '\x0A\x00' + '\x00\x00';
            zipHeader += data.compressionType;
            zipHeader += this.getBytes(this.getModifiedTime(date), 2);
            zipHeader += this.getBytes(this.getModifiedDate(date), 2);
            zipHeader += this.getBytes(data.crc32Value, 4);
            zipHeader += this.getBytes(data.compressedSize, 4);
            zipHeader += this.getBytes(data.uncompressedDataSize, 4);
            zipHeader += this.getBytes(data.fileName.length, 2);
            zipHeader += this.getBytes(0, 2);
            return zipHeader;
        };
        ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {
            var cenDirLen = 0;
            var buffer = [];
            for (var i = 0; i < zipData.length; i++) {
                var item = zipData[i];
                cenDirLen += item.centralDir.length;
                buffer.push(this.getArrayBuffer(item.localHeader));
                while (item.compressedData.compressedData.length) {
                    buffer.push(item.compressedData.compressedData.shift().buffer);
                }
            }
            for (var i = 0; i < zipData.length; i++) {
                buffer.push(this.getArrayBuffer(zipData[i].centralDir));
            }
            buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));
            var blob = new Blob(buffer, { type: 'application/zip' });
            if (!skipFileSave) {
                ej2_file_utils_1.Save.save(fileName, blob);
            }
            return blob;
        };
        ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {
            var directoryHeader = 'PK\x01\x02' +
                this.getBytes(0x0014, 2) + localHeader +
                this.getBytes(0, 2) +
                '\x00\x00' + '\x00\x00' +
                this.getBytes(externalFileAttribute, 4) +
                this.getBytes(offset, 4) +
                data.fileName;
            return directoryHeader;
        };
        ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {
            var dirEnd = 'PK\x05\x06' + '\x00\x00' + '\x00\x00' +
                this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +
                this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +
                this.getBytes(0, 2);
            return dirEnd;
        };
        ZipArchive.prototype.getArrayBuffer = function (input) {
            var a = new Uint8Array(input.length);
            for (var j = 0; j < input.length; ++j) {
                a[j] = input.charCodeAt(j) & 0xFF;
            }
            return a.buffer;
        };
        ZipArchive.prototype.getBytes = function (value, offset) {
            var bytes = '';
            for (var i = 0; i < offset; i++) {
                bytes += String.fromCharCode(value & 0xff);
                value = value >>> 8;
            }
            return bytes;
        };
        ZipArchive.prototype.getModifiedTime = function (date) {
            var modTime = date.getHours();
            modTime = modTime << 6;
            modTime = modTime | date.getMinutes();
            modTime = modTime << 5;
            return modTime = modTime | date.getSeconds() / 2;
        };
        ZipArchive.prototype.getModifiedDate = function (date) {
            var modiDate = date.getFullYear() - 1980;
            modiDate = modiDate << 4;
            modiDate = modiDate | (date.getMonth() + 1);
            modiDate = modiDate << 5;
            return modiDate = modiDate | date.getDate();
        };
        ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {
            crc32Value ^= -1;
            for (var i = 0; i < input.length; i++) {
                crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];
            }
            return (crc32Value ^ (-1));
        };
        return ZipArchive;
    }());
    exports.ZipArchive = ZipArchive;
    var ZipArchiveItem = (function () {
        function ZipArchiveItem(data, itemName) {
            if (data === null || data === undefined) {
                throw new Error('ArgumentException: data cannot be null or undefined');
            }
            if (itemName === null || itemName === undefined) {
                throw new Error('ArgumentException: string cannot be null or undefined');
            }
            if (itemName.length === 0) {
                throw new Error('string cannot be empty');
            }
            this.data = data;
            this.name = itemName;
        }
        Object.defineProperty(ZipArchiveItem.prototype, "name", {
            get: function () {
                return this.fileName;
            },
            set: function (value) {
                this.fileName = value;
            },
            enumerable: true,
            configurable: true
        });
        ZipArchiveItem.prototype.destroy = function () {
            this.fileName = undefined;
            this.data = undefined;
        };
        return ZipArchiveItem;
    }());
    exports.ZipArchiveItem = ZipArchiveItem;
    (function () {
        var i;
        for (var j = 0; j < 256; j++) {
            i = j;
            for (var k = 0; k < 8; k++) {
                i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));
            }
            crc32Table[j] = i;
        }
    })();
});
