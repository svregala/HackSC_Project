define(["require", "exports", "./ttf-table-info", "./../../collections/dictionary", "./ttf-name-table", "./ttf-name-record", "./ttf-head-table", "./ttf-metrics", "./ttf-horizontal-header-table", "./ttf-OS2-Table", "./ttf-post-table", "./ttf-long-hor-metric", "./ttf-cmap-sub-table", "./ttf-cmap-table", "./ttf-glyph-info", "./ttf-loca-table", "./ttf-apple-cmap-sub-table", "./ttf-microsoft-cmap-sub-table", "./ttf-trimmed-cmap-sub-table", "./ttf-glyph-header", "./../../drawing/pdf-drawing", "./string-tokenizer", "./enum", "./enum", "./../../input-output/big-endian-writer"], function (require, exports, ttf_table_info_1, dictionary_1, ttf_name_table_1, ttf_name_record_1, ttf_head_table_1, ttf_metrics_1, ttf_horizontal_header_table_1, ttf_OS2_Table_1, ttf_post_table_1, ttf_long_hor_metric_1, ttf_cmap_sub_table_1, ttf_cmap_table_1, ttf_glyph_info_1, ttf_loca_table_1, ttf_apple_cmap_sub_table_1, ttf_microsoft_cmap_sub_table_1, ttf_trimmed_cmap_sub_table_1, ttf_glyph_header_1, pdf_drawing_1, string_tokenizer_1, enum_1, enum_2, big_endian_writer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TtfReader = (function () {
        function TtfReader(fontData) {
            this.int32Size = 4;
            this.isTtcFont = false;
            this.isMacTtf = false;
            this.metricsName = '';
            this.isMacTTF = false;
            this.missedGlyphs = 0;
            this.tableNames = ['cvt ', 'fpgm', 'glyf', 'head', 'hhea', 'hmtx', 'loca', 'maxp', 'prep'];
            this.entrySelectors = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4];
            this.fontData = fontData;
            this.initialize();
        }
        Object.defineProperty(TtfReader.prototype, "macintosh", {
            get: function () {
                if (this.macintoshDictionary === null || this.macintoshDictionary === undefined) {
                    this.macintoshDictionary = new dictionary_1.Dictionary();
                }
                return this.macintoshDictionary;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TtfReader.prototype, "microsoft", {
            get: function () {
                if (this.microsoftDictionary === null || this.microsoftDictionary === undefined) {
                    this.microsoftDictionary = new dictionary_1.Dictionary();
                }
                return this.microsoftDictionary;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TtfReader.prototype, "macintoshGlyphs", {
            get: function () {
                if (this.internalMacintoshGlyphs === null || this.internalMacintoshGlyphs === undefined) {
                    this.internalMacintoshGlyphs = new dictionary_1.Dictionary();
                }
                return this.internalMacintoshGlyphs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TtfReader.prototype, "microsoftGlyphs", {
            get: function () {
                if (this.internalMicrosoftGlyphs === null || this.internalMicrosoftGlyphs === undefined) {
                    this.internalMicrosoftGlyphs = new dictionary_1.Dictionary();
                }
                return this.internalMicrosoftGlyphs;
            },
            enumerable: true,
            configurable: true
        });
        TtfReader.prototype.initialize = function () {
            if (this.metrics === undefined) {
                this.metrics = new ttf_metrics_1.TtfMetrics();
            }
            this.readFontDictionary();
            var nameTable = this.readNameTable();
            var headTable = this.readHeadTable();
            this.initializeFontName(nameTable);
            this.metrics.macStyle = headTable.macStyle;
        };
        TtfReader.prototype.readFontDictionary = function () {
            this.offset = 0;
            var version = this.checkPreambula();
            var numTables = this.readInt16(this.offset);
            var searchRange = this.readInt16(this.offset);
            var entrySelector = this.readInt16(this.offset);
            var rangeShift = this.readInt16(this.offset);
            if (this.tableDirectory === undefined) {
                this.tableDirectory = new dictionary_1.Dictionary();
            }
            for (var i = 0; i < numTables; ++i) {
                var table = new ttf_table_info_1.TtfTableInfo();
                var tableKey = this.readString(this.int32Size);
                table.checksum = this.readInt32(this.offset);
                table.offset = this.readInt32(this.offset);
                table.length = this.readInt32(this.offset);
                this.tableDirectory.setValue(tableKey, table);
            }
            this.lowestPosition = this.offset;
            if (!this.isTtcFont) {
                this.fixOffsets();
            }
        };
        TtfReader.prototype.fixOffsets = function () {
            var minOffset = Number.MAX_VALUE;
            var tableKeys = this.tableDirectory.keys();
            for (var i = 0; i < tableKeys.length; i++) {
                var value = this.tableDirectory.getValue(tableKeys[i]);
                var offset = value.offset;
                if (minOffset > offset) {
                    minOffset = offset;
                    if (minOffset <= this.lowestPosition) {
                        break;
                    }
                }
            }
            var shift = minOffset - this.lowestPosition;
            if (shift !== 0) {
                var table = new dictionary_1.Dictionary();
                for (var i = 0; i < tableKeys.length; i++) {
                    var value = this.tableDirectory.getValue(tableKeys[i]);
                    value.offset -= shift;
                    table.setValue(tableKeys[i], value);
                }
                this.tableDirectory = table;
            }
        };
        TtfReader.prototype.checkPreambula = function () {
            var version = this.readInt32(this.offset);
            this.isMacTtf = (version === 0x74727565) ? true : false;
            if (version !== 0x10000 && version !== 0x74727565 && version !== 0x4f54544f) {
                this.isTtcFont = true;
                this.offset = 0;
                var fontTag = this.readString(4);
                if (fontTag !== 'ttcf') {
                    throw new Error('Can not read TTF font data');
                }
                this.offset += 4;
                var ttcIdentificationNumber = this.readInt32(this.offset);
                if (ttcIdentificationNumber < 0) {
                    throw new Error('Can not read TTF font data');
                }
                this.offset = this.readInt32(this.offset);
                version = this.readInt32(this.offset);
            }
            return version;
        };
        TtfReader.prototype.readNameTable = function () {
            var tableInfo = this.getTable('name');
            this.offset = tableInfo.offset;
            var table = new ttf_name_table_1.TtfNameTable();
            table.formatSelector = this.readUInt16(this.offset);
            table.recordsCount = this.readUInt16(this.offset);
            table.offset = this.readUInt16(this.offset);
            table.nameRecords = [];
            var recordSize = 12;
            var position = this.offset;
            for (var i = 0; i < table.recordsCount; i++) {
                this.offset = position;
                var record = new ttf_name_record_1.TtfNameRecord();
                record.platformID = this.readUInt16(this.offset);
                record.encodingID = this.readUInt16(this.offset);
                record.languageID = this.readUInt16(this.offset);
                record.nameID = this.readUInt16(this.offset);
                record.length = this.readUInt16(this.offset);
                record.offset = this.readUInt16(this.offset);
                this.offset = tableInfo.offset + table.offset + record.offset;
                var unicode = (record.platformID === 0 || record.platformID === 3);
                record.name = this.readString(record.length, unicode);
                table.nameRecords[i] = record;
                position += recordSize;
            }
            return table;
        };
        TtfReader.prototype.readHeadTable = function () {
            var tableInfo = this.getTable('head');
            this.offset = tableInfo.offset;
            var table = new ttf_head_table_1.TtfHeadTable();
            table.version = this.readFixed(this.offset);
            table.fontRevision = this.readFixed(this.offset);
            table.checkSumAdjustment = this.readUInt32(this.offset);
            table.magicNumber = this.readUInt32(this.offset);
            table.flags = this.readUInt16(this.offset);
            table.unitsPerEm = this.readUInt16(this.offset);
            table.created = this.readInt64(this.offset);
            table.modified = this.readInt64(this.offset);
            table.xMin = this.readInt16(this.offset);
            table.yMin = this.readInt16(this.offset);
            table.xMax = this.readInt16(this.offset);
            table.yMax = this.readInt16(this.offset);
            table.macStyle = this.readUInt16(this.offset);
            table.lowestReadableSize = this.readUInt16(this.offset);
            table.fontDirectionHint = this.readInt16(this.offset);
            table.indexToLocalFormat = this.readInt16(this.offset);
            table.glyphDataFormat = this.readInt16(this.offset);
            return table;
        };
        TtfReader.prototype.readHorizontalHeaderTable = function () {
            var tableInfo = this.getTable('hhea');
            this.offset = tableInfo.offset;
            var table = new ttf_horizontal_header_table_1.TtfHorizontalHeaderTable();
            table.version = this.readFixed(this.offset);
            table.ascender = this.readInt16(this.offset);
            table.descender = this.readInt16(this.offset);
            table.lineGap = this.readInt16(this.offset);
            table.advanceWidthMax = this.readUInt16(this.offset);
            table.minLeftSideBearing = this.readInt16(this.offset);
            table.minRightSideBearing = this.readInt16(this.offset);
            table.xMaxExtent = this.readInt16(this.offset);
            table.caretSlopeRise = this.readInt16(this.offset);
            table.caretSlopeRun = this.readInt16(this.offset);
            this.offset += 10;
            table.metricDataFormat = this.readInt16(this.offset);
            table.numberOfHMetrics = this.readUInt16(this.offset);
            return table;
        };
        TtfReader.prototype.readOS2Table = function () {
            var tableInfo = this.getTable('OS/2');
            this.offset = tableInfo.offset;
            var table = new ttf_OS2_Table_1.TtfOS2Table();
            table.version = this.readUInt16(this.offset);
            table.xAvgCharWidth = this.readInt16(this.offset);
            table.usWeightClass = this.readUInt16(this.offset);
            table.usWidthClass = this.readUInt16(this.offset);
            table.fsType = this.readInt16(this.offset);
            table.ySubscriptXSize = this.readInt16(this.offset);
            table.ySubscriptYSize = this.readInt16(this.offset);
            table.ySubscriptXOffset = this.readInt16(this.offset);
            table.ySubscriptYOffset = this.readInt16(this.offset);
            table.ySuperscriptXSize = this.readInt16(this.offset);
            table.ySuperscriptYSize = this.readInt16(this.offset);
            table.ySuperscriptXOffset = this.readInt16(this.offset);
            table.ySuperscriptYOffset = this.readInt16(this.offset);
            table.yStrikeoutSize = this.readInt16(this.offset);
            table.yStrikeoutPosition = this.readInt16(this.offset);
            table.sFamilyClass = this.readInt16(this.offset);
            table.panose = this.readBytes(10);
            table.ulUnicodeRange1 = this.readUInt32(this.offset);
            table.ulUnicodeRange2 = this.readUInt32(this.offset);
            table.ulUnicodeRange3 = this.readUInt32(this.offset);
            table.ulUnicodeRange4 = this.readUInt32(this.offset);
            table.vendorIdentifier = this.readBytes(4);
            table.fsSelection = this.readUInt16(this.offset);
            table.usFirstCharIndex = this.readUInt16(this.offset);
            table.usLastCharIndex = this.readUInt16(this.offset);
            table.sTypoAscender = this.readInt16(this.offset);
            table.sTypoDescender = this.readInt16(this.offset);
            table.sTypoLineGap = this.readInt16(this.offset);
            table.usWinAscent = this.readUInt16(this.offset);
            table.usWinDescent = this.readUInt16(this.offset);
            table.ulCodePageRange1 = this.readUInt32(this.offset);
            table.ulCodePageRange2 = this.readUInt32(this.offset);
            if (table.version > 1) {
                table.sxHeight = this.readInt16(this.offset);
                table.sCapHeight = this.readInt16(this.offset);
                table.usDefaultChar = this.readUInt16(this.offset);
                table.usBreakChar = this.readUInt16(this.offset);
                table.usMaxContext = this.readUInt16(this.offset);
            }
            else {
                table.sxHeight = 0;
                table.sCapHeight = 0;
                table.usDefaultChar = 0;
                table.usBreakChar = 0;
                table.usMaxContext = 0;
            }
            return table;
        };
        TtfReader.prototype.readPostTable = function () {
            var tableInfo = this.getTable('post');
            this.offset = tableInfo.offset;
            var table = new ttf_post_table_1.TtfPostTable();
            table.formatType = this.readFixed(this.offset);
            table.italicAngle = this.readFixed(this.offset);
            table.underlinePosition = this.readInt16(this.offset);
            table.underlineThickness = this.readInt16(this.offset);
            table.isFixedPitch = this.readUInt32(this.offset);
            table.minType42 = this.readUInt32(this.offset);
            table.maxType42 = this.readUInt32(this.offset);
            table.minType1 = this.readUInt32(this.offset);
            table.maxType1 = this.readUInt32(this.offset);
            return table;
        };
        TtfReader.prototype.readWidthTable = function (glyphCount, unitsPerEm) {
            var tableInfo = this.getTable('hmtx');
            this.offset = tableInfo.offset;
            var width = [];
            for (var i = 0; i < glyphCount; i++) {
                var glyph = new ttf_long_hor_metric_1.TtfLongHorMetric();
                glyph.advanceWidth = this.readUInt16(this.offset);
                glyph.lsb = this.readInt16(this.offset);
                var glyphWidth = glyph.advanceWidth * 1000 / unitsPerEm;
                width.push(Math.floor(glyphWidth));
            }
            return width;
        };
        TtfReader.prototype.readCmapTable = function () {
            var tableInfo = this.getTable('cmap');
            this.offset = tableInfo.offset;
            var table = new ttf_cmap_table_1.TtfCmapTable();
            table.version = this.readUInt16(this.offset);
            table.tablesCount = this.readUInt16(this.offset);
            var position = this.offset;
            var subTables = [];
            for (var i = 0; i < table.tablesCount; i++) {
                this.offset = position;
                var subTable = new ttf_cmap_sub_table_1.TtfCmapSubTable();
                subTable.platformID = this.readUInt16(this.offset);
                subTable.encodingID = this.readUInt16(this.offset);
                subTable.offset = this.readUInt32(this.offset);
                position = this.offset;
                this.readCmapSubTable(subTable);
                subTables[i] = subTable;
            }
            return subTables;
        };
        TtfReader.prototype.readCmapSubTable = function (subTable) {
            var tableInfo = this.getTable('cmap');
            this.offset = tableInfo.offset + subTable.offset;
            var format = this.readUInt16(this.offset);
            var encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);
            var platform = (encoding === enum_1.TtfCmapEncoding.Macintosh) ? enum_1.TtfPlatformID.Macintosh : enum_1.TtfPlatformID.Microsoft;
            if (encoding !== enum_1.TtfCmapEncoding.Unknown) {
                switch (format) {
                    case enum_1.TtfCmapFormat.Apple:
                        this.readAppleCmapTable(subTable, encoding);
                        break;
                    case enum_1.TtfCmapFormat.Microsoft:
                        this.readMicrosoftCmapTable(subTable, encoding);
                        break;
                    case enum_1.TtfCmapFormat.Trimmed:
                        this.readTrimmedCmapTable(subTable, encoding);
                        break;
                }
            }
        };
        TtfReader.prototype.readAppleCmapTable = function (subTable, encoding) {
            var tableInfo = this.getTable('cmap');
            this.offset = tableInfo.offset + subTable.offset;
            var table = new ttf_apple_cmap_sub_table_1.TtfAppleCmapSubTable();
            table.format = this.readUInt16(this.offset);
            table.length = this.readUInt16(this.offset);
            table.version = this.readUInt16(this.offset);
            if (this.maxMacIndex === null || this.maxMacIndex === undefined) {
                this.maxMacIndex = 0;
            }
            for (var i = 0; i < 256; ++i) {
                var glyphInfo = new ttf_glyph_info_1.TtfGlyphInfo();
                glyphInfo.index = this.readByte(this.offset);
                glyphInfo.width = this.getWidth(glyphInfo.index);
                glyphInfo.charCode = i;
                this.macintosh.setValue(i, glyphInfo);
                this.addGlyph(glyphInfo, encoding);
                this.maxMacIndex = Math.max(i, this.maxMacIndex);
            }
        };
        TtfReader.prototype.readMicrosoftCmapTable = function (subTable, encoding) {
            var tableInfo = this.getTable('cmap');
            this.offset = tableInfo.offset + subTable.offset;
            var collection = (encoding === enum_1.TtfCmapEncoding.Unicode) ? this.microsoft : this.macintosh;
            var table = new ttf_microsoft_cmap_sub_table_1.TtfMicrosoftCmapSubTable();
            table.format = this.readUInt16(this.offset);
            table.length = this.readUInt16(this.offset);
            table.version = this.readUInt16(this.offset);
            table.segCountX2 = this.readUInt16(this.offset);
            table.searchRange = this.readUInt16(this.offset);
            table.entrySelector = this.readUInt16(this.offset);
            table.rangeShift = this.readUInt16(this.offset);
            var segCount = table.segCountX2 / 2;
            table.endCount = this.readUshortArray(segCount);
            table.reservedPad = this.readUInt16(this.offset);
            table.startCount = this.readUshortArray(segCount);
            table.idDelta = this.readUshortArray(segCount);
            table.idRangeOffset = this.readUshortArray(segCount);
            var length = (table.length / 2 - 8) - (segCount * 4);
            table.glyphID = this.readUshortArray(length);
            var codeOffset = 0;
            var index = 0;
            for (var j = 0; j < segCount; j++) {
                for (var k = table.startCount[j]; k <= table.endCount[j] && k !== 65535; k++) {
                    if (table.idRangeOffset[j] === 0) {
                        codeOffset = (k + table.idDelta[j]) & 65535;
                    }
                    else {
                        index = j + table.idRangeOffset[j] / 2 - segCount + k - table.startCount[j];
                        if (index >= table.glyphID.length) {
                            continue;
                        }
                        codeOffset = (table.glyphID[index] + table.idDelta[j]) & 65535;
                    }
                    var glyph = new ttf_glyph_info_1.TtfGlyphInfo();
                    glyph.index = codeOffset;
                    glyph.width = this.getWidth(glyph.index);
                    var id = (encoding === enum_1.TtfCmapEncoding.Symbol) ? ((k & 0xff00) === 0xf000 ? k & 0xff : k) : k;
                    glyph.charCode = id;
                    collection.setValue(id, glyph);
                    this.addGlyph(glyph, encoding);
                }
            }
        };
        TtfReader.prototype.readTrimmedCmapTable = function (subTable, encoding) {
            var tableInfo = this.getTable('cmap');
            this.offset = tableInfo.offset + subTable.offset;
            var table = new ttf_trimmed_cmap_sub_table_1.TtfTrimmedCmapSubTable();
            table.format = this.readUInt16(this.offset);
            table.length = this.readUInt16(this.offset);
            table.version = this.readUInt16(this.offset);
            table.firstCode = this.readUInt16(this.offset);
            table.entryCount = this.readUInt16(this.offset);
            for (var i = 0; i < table.entryCount; ++i) {
                var glyphInfo = new ttf_glyph_info_1.TtfGlyphInfo();
                glyphInfo.index = this.readUInt16(this.offset);
                glyphInfo.width = this.getWidth(glyphInfo.index);
                glyphInfo.charCode = i + table.firstCode;
                this.macintosh.setValue(i, glyphInfo);
                this.addGlyph(glyphInfo, encoding);
                this.maxMacIndex = Math.max(i, this.maxMacIndex);
            }
        };
        TtfReader.prototype.initializeFontName = function (nameTable) {
            for (var i = 0; i < nameTable.recordsCount; i++) {
                var record = nameTable.nameRecords[i];
                if (record.nameID === 1) {
                    this.metrics.fontFamily = record.name;
                }
                else if (record.nameID === 6) {
                    this.metrics.postScriptName = record.name;
                }
                if (this.metrics.fontFamily !== null && this.metrics.fontFamily !== undefined && this.metrics.postScriptName !== null && this.metrics.postScriptName !== undefined) {
                    break;
                }
            }
        };
        TtfReader.prototype.getTable = function (name) {
            var table = new ttf_table_info_1.TtfTableInfo();
            var obj;
            if (this.tableDirectory.containsKey(name)) {
                obj = this.tableDirectory.getValue(name);
            }
            if (obj !== null && obj !== undefined) {
                table = obj;
            }
            return table;
        };
        TtfReader.prototype.getWidth = function (glyphCode) {
            glyphCode = (glyphCode < this.width.length) ? glyphCode : this.width.length - 1;
            return this.width[glyphCode];
        };
        TtfReader.prototype.getCmapEncoding = function (platformID, encodingID) {
            var format = enum_1.TtfCmapEncoding.Unknown;
            if (platformID == enum_1.TtfPlatformID.Microsoft && encodingID == enum_2.TtfMicrosoftEncodingID.Undefined) {
                format = enum_1.TtfCmapEncoding.Symbol;
            }
            else if (platformID == enum_1.TtfPlatformID.Microsoft && encodingID == enum_2.TtfMicrosoftEncodingID.Unicode) {
                format = enum_1.TtfCmapEncoding.Unicode;
            }
            else if (platformID == enum_1.TtfPlatformID.Macintosh && encodingID == enum_2.TtfMacintoshEncodingID.Roman) {
                format = enum_1.TtfCmapEncoding.Macintosh;
            }
            return format;
        };
        TtfReader.prototype.addGlyph = function (glyph, encoding) {
            var collection = null;
            switch (encoding) {
                case enum_1.TtfCmapEncoding.Unicode:
                    collection = this.microsoftGlyphs;
                    break;
                case enum_1.TtfCmapEncoding.Macintosh:
                case enum_1.TtfCmapEncoding.Symbol:
                    collection = this.macintoshGlyphs;
                    break;
            }
            collection.setValue(glyph.index, glyph);
        };
        TtfReader.prototype.initializeMetrics = function (nameTable, headTable, horizontalHeadTable, os2Table, postTable, cmapTables) {
            this.initializeFontName(nameTable);
            var bSymbol = false;
            for (var i = 0; i < cmapTables.length; i++) {
                var subTable = cmapTables[i];
                var encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);
                if (encoding === enum_1.TtfCmapEncoding.Symbol) {
                    bSymbol = true;
                    break;
                }
            }
            this.metrics.isSymbol = bSymbol;
            this.metrics.macStyle = headTable.macStyle;
            this.metrics.isFixedPitch = (postTable.isFixedPitch !== 0);
            this.metrics.italicAngle = postTable.italicAngle;
            var factor = 1000 / headTable.unitsPerEm;
            this.metrics.winAscent = os2Table.sTypoAscender * factor;
            this.metrics.macAscent = horizontalHeadTable.ascender * factor;
            this.metrics.capHeight = (os2Table.sCapHeight !== 0) ? os2Table.sCapHeight : 0.7 * headTable.unitsPerEm * factor;
            this.metrics.winDescent = os2Table.sTypoDescender * factor;
            this.metrics.macDescent = horizontalHeadTable.descender * factor;
            this.metrics.leading = (os2Table.sTypoAscender - os2Table.sTypoDescender + os2Table.sTypoLineGap) * factor;
            this.metrics.lineGap = Math.ceil(horizontalHeadTable.lineGap * factor);
            var left = headTable.xMin * factor;
            var top = Math.ceil(this.metrics.macAscent + this.metrics.lineGap);
            var right = headTable.xMax * factor;
            var bottom = this.metrics.macDescent;
            this.metrics.fontBox = new pdf_drawing_1.Rectangle(left, top, right, bottom);
            this.metrics.stemV = 80;
            this.metrics.widthTable = this.updateWidth();
            this.metrics.contains = this.tableDirectory.containsKey('CFF');
            this.metrics.subScriptSizeFactor = headTable.unitsPerEm / os2Table.ySubscriptYSize;
            this.metrics.superscriptSizeFactor = headTable.unitsPerEm / os2Table.ySuperscriptYSize;
        };
        TtfReader.prototype.updateWidth = function () {
            var count = 256;
            var bytes = [];
            if (this.metrics.isSymbol) {
                for (var i = 0; i < count; i++) {
                    var glyphInfo = this.getGlyph(String.fromCharCode(i));
                    bytes[i] = (glyphInfo.empty) ? 0 : glyphInfo.width;
                }
            }
            else {
                var byteToProcess = [];
                var unknown = '?';
                var space = String.fromCharCode(32);
                for (var i = 0; i < count; i++) {
                    byteToProcess[0] = i;
                    var text = this.getString(byteToProcess, 0, byteToProcess.length);
                    var ch = (text.length > 0) ? text[0] : unknown;
                    var glyphInfo = this.getGlyph(ch);
                    if (!glyphInfo.empty) {
                        bytes[i] = glyphInfo.width;
                    }
                    else {
                        glyphInfo = this.getGlyph(space);
                        bytes[i] = (glyphInfo.empty) ? 0 : glyphInfo.width;
                    }
                }
            }
            return bytes;
        };
        TtfReader.prototype.getDefaultGlyph = function () {
            var glyph = this.getGlyph(string_tokenizer_1.StringTokenizer.whiteSpace);
            return glyph;
        };
        TtfReader.prototype.getString = function (byteToProcess, start, length) {
            var result = '';
            for (var index = 0; index < length; index++) {
                result += String.fromCharCode(byteToProcess[index + start]);
            }
            return result;
        };
        TtfReader.prototype.readLocaTable = function (bShort) {
            var tableInfo = this.getTable('loca');
            this.offset = tableInfo.offset;
            var table = new ttf_loca_table_1.TtfLocaTable();
            var buffer = null;
            if (bShort) {
                var len = tableInfo.length / 2;
                buffer = [];
                for (var i = 0; i < len; i++) {
                    buffer[i] = this.readUInt16(this.offset) * 2;
                }
            }
            else {
                var len = tableInfo.length / 4;
                buffer = [];
                for (var i = 0; i < len; i++) {
                    buffer[i] = this.readUInt32(this.offset);
                }
            }
            table.offsets = buffer;
            return table;
        };
        TtfReader.prototype.updateGlyphChars = function (glyphChars, locaTable) {
            if (!glyphChars.containsKey(0)) {
                glyphChars.setValue(0, 0);
            }
            var clone = new dictionary_1.Dictionary();
            var glyphCharKeys = glyphChars.keys();
            for (var i = 0; i < glyphCharKeys.length; i++) {
                clone.setValue(glyphCharKeys[0], glyphChars.getValue(glyphCharKeys[0]));
            }
            for (var i = 0; i < glyphCharKeys.length; i++) {
                var nextKey = glyphCharKeys[0];
                this.processCompositeGlyph(glyphChars, nextKey, locaTable);
            }
        };
        TtfReader.prototype.processCompositeGlyph = function (glyphChars, glyph, locaTable) {
            if (glyph < locaTable.offsets.length - 1) {
                var glyphOffset = locaTable.offsets[glyph];
                if (glyphOffset !== locaTable.offsets[glyph + 1]) {
                    var tableInfo = this.getTable('glyf');
                    this.offset = tableInfo.offset + glyphOffset;
                    var glyphHeader = new ttf_glyph_header_1.TtfGlyphHeader();
                    glyphHeader.numberOfContours = this.readInt16(this.offset);
                    glyphHeader.xMin = this.readInt16(this.offset);
                    glyphHeader.yMin = this.readInt16(this.offset);
                    glyphHeader.xMax = this.readInt16(this.offset);
                    glyphHeader.yMax = this.readInt16(this.offset);
                    if (glyphHeader.numberOfContours < 0) {
                        var skipBytes = 0;
                        var entry = true;
                        while (entry) {
                            var flags = this.readUInt16(this.offset);
                            var glyphIndex = this.readUInt16(this.offset);
                            if (!glyphChars.containsKey(glyphIndex)) {
                                glyphChars.setValue(glyphIndex, 0);
                            }
                            if ((flags & enum_2.TtfCompositeGlyphFlags.MoreComponents) === 0) {
                                break;
                            }
                            skipBytes = ((flags & enum_2.TtfCompositeGlyphFlags.Arg1And2AreWords) !== 0) ? 4 : 2;
                            if ((flags & enum_2.TtfCompositeGlyphFlags.WeHaveScale) !== 0) {
                                skipBytes += 2;
                            }
                            else if ((flags & enum_2.TtfCompositeGlyphFlags.WeHaveAnXyScale) !== 0) {
                                skipBytes += 4;
                            }
                            else if ((flags & enum_2.TtfCompositeGlyphFlags.WeHaveTwoByTwo) !== 0) {
                                skipBytes += 2 * 4;
                            }
                            this.offset += skipBytes;
                        }
                    }
                }
            }
        };
        TtfReader.prototype.generateGlyphTable = function (glyphChars, locaTable, newLocaTable, newGlyphTable) {
            newLocaTable = [];
            var activeGlyphs = glyphChars.keys();
            activeGlyphs.sort(function (a, b) { return a - b; });
            var glyphSize = 0;
            for (var i = 0; i < activeGlyphs.length; i++) {
                var glyphIndex = activeGlyphs[i];
                if (locaTable.offsets.length > 0) {
                    glyphSize += locaTable.offsets[glyphIndex + 1] - locaTable.offsets[glyphIndex];
                }
            }
            var glyphSizeAligned = this.align(glyphSize);
            newGlyphTable = [];
            for (var i = 0; i < glyphSizeAligned; i++) {
                newGlyphTable.push(0);
            }
            var nextGlyphOffset = 0;
            var nextGlyphIndex = 0;
            var table = this.getTable('glyf');
            for (var i = 0; i < locaTable.offsets.length; i++) {
                newLocaTable.push(nextGlyphOffset);
                if (nextGlyphIndex < activeGlyphs.length && activeGlyphs[nextGlyphIndex] === i) {
                    ++nextGlyphIndex;
                    newLocaTable[i] = nextGlyphOffset;
                    var oldGlyphOffset = locaTable.offsets[i];
                    var oldNextGlyphOffset = locaTable.offsets[i + 1] - oldGlyphOffset;
                    if (oldNextGlyphOffset > 0) {
                        this.offset = table.offset + oldGlyphOffset;
                        var result = this.read(newGlyphTable, nextGlyphOffset, oldNextGlyphOffset);
                        newGlyphTable = result.buffer;
                        nextGlyphOffset += oldNextGlyphOffset;
                    }
                }
            }
            return { glyphTableSize: glyphSize, newLocaTable: newLocaTable, newGlyphTable: newGlyphTable };
        };
        TtfReader.prototype.updateLocaTable = function (newLocaTable, bLocaIsShort, newLocaTableOut) {
            if (newLocaTable === null) {
                throw new Error('Argument Null Exception : newLocaTable');
            }
            var size = (bLocaIsShort) ? newLocaTable.length * 2 : newLocaTable.length * 4;
            var count = this.align(size);
            var writer = new big_endian_writer_1.BigEndianWriter(count);
            for (var i = 0; i < newLocaTable.length; i++) {
                var value = newLocaTable[i];
                if (bLocaIsShort) {
                    value /= 2;
                    writer.writeShort(value);
                }
                else {
                    writer.writeInt(value);
                }
            }
            return { newLocaUpdated: writer.data, newLocaSize: size };
        };
        TtfReader.prototype.align = function (value) {
            return (value + 3) & (~3);
        };
        TtfReader.prototype.getFontProgram = function (newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
            if (newLocaTableOut === null) {
                throw new Error('Argument Null Exception : newLocaTableOut');
            }
            if (newGlyphTable === null) {
                throw new Error('Argument Null Exception : newGlyphTable');
            }
            var tableNames = this.tableNames;
            var result = this.getFontProgramLength(newLocaTableOut, newGlyphTable, 0);
            var fontProgramLength = result.fontProgramLength;
            var numTables = result.numTables;
            var writer = new big_endian_writer_1.BigEndianWriter(fontProgramLength);
            writer.writeInt(0x10000);
            writer.writeShort(numTables);
            var entrySelector = this.entrySelectors[numTables];
            writer.writeShort((1 << (entrySelector & 31)) * 16);
            writer.writeShort(entrySelector);
            writer.writeShort((numTables - (1 << (entrySelector & 31))) * 16);
            this.writeCheckSums(writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize);
            this.writeGlyphs(writer, newLocaTableOut, newGlyphTable);
            return writer.data;
        };
        TtfReader.prototype.getFontProgramLength = function (newLocaTableOut, newGlyphTable, numTables) {
            if (newLocaTableOut === null) {
                throw new Error('Argument Null Exception : newLocaTableOut');
            }
            if (newGlyphTable === null) {
                throw new Error('Argument Null Exception : newGlyphTable');
            }
            numTables = 2;
            var tableNames = this.tableNames;
            var fontProgramLength = 0;
            for (var i = 0; i < tableNames.length; i++) {
                var tableName = tableNames[i];
                if (tableName !== 'glyf' && tableName !== 'loca') {
                    var table = this.getTable(tableName);
                    if (!table.empty) {
                        ++numTables;
                        fontProgramLength += this.align(table.length);
                    }
                }
            }
            fontProgramLength += newLocaTableOut.length;
            fontProgramLength += newGlyphTable.length;
            var usedTablesSize = numTables * 16 + (3 * 4);
            fontProgramLength += usedTablesSize;
            return { fontProgramLength: fontProgramLength, numTables: numTables };
        };
        TtfReader.prototype.writeCheckSums = function (writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
            if (writer === null) {
                throw new Error('Argument Null Exception : writer');
            }
            if (newLocaTableOut === null) {
                throw new Error('Argument Null Exception : newLocaTableOut');
            }
            if (newGlyphTable === null) {
                throw new Error('Argument Null Exception : newGlyphTable');
            }
            var tableNames = this.tableNames;
            var usedTablesSize = numTables * 16 + (3 * 4);
            var nextTableSize = 0;
            for (var i = 0; i < tableNames.length; i++) {
                var tableName = tableNames[i];
                var tableInfo = this.getTable(tableName);
                if (tableInfo.empty) {
                    continue;
                }
                writer.writeString(tableName);
                if (tableName === 'glyf') {
                    var checksum = this.calculateCheckSum(newGlyphTable);
                    writer.writeInt(checksum);
                    nextTableSize = glyphTableSize;
                }
                else if (tableName === 'loca') {
                    var checksum = this.calculateCheckSum(newLocaTableOut);
                    writer.writeInt(checksum);
                    nextTableSize = locaTableSize;
                }
                else {
                    writer.writeInt(tableInfo.checksum);
                    nextTableSize = tableInfo.length;
                }
                writer.writeUInt(usedTablesSize);
                writer.writeUInt(nextTableSize);
                usedTablesSize += this.align(nextTableSize);
            }
        };
        TtfReader.prototype.calculateCheckSum = function (bytes) {
            if (bytes === null) {
                throw new Error('Argument Null Exception : bytes');
            }
            var pos = 0;
            var byte1 = 0;
            var byte2 = 0;
            var byte3 = 0;
            var byte4 = 0;
            for (var i = 0; i < (bytes.length + 1) / 4; i++) {
                byte4 += (bytes[pos++] & 255);
                byte3 += (bytes[pos++] & 255);
                byte2 += (bytes[pos++] & 255);
                byte1 += (bytes[pos++] & 255);
            }
            var result = byte1;
            result += (byte2 << 8);
            result += (byte3 << 16);
            result += (byte4 << 24);
            return result;
        };
        TtfReader.prototype.writeGlyphs = function (writer, newLocaTable, newGlyphTable) {
            if (writer === null) {
                throw new Error('Argument Null Exception : writer');
            }
            if (newLocaTable === null) {
                throw new Error('Argument Null Exception : newLocaTableOut');
            }
            if (newGlyphTable === null) {
                throw new Error('Argument Null Exception : newGlyphTable');
            }
            var tableNames = this.tableNames;
            for (var i = 0; i < tableNames.length; i++) {
                var tableName = tableNames[i];
                var tableInfo = this.getTable(tableName);
                if (tableInfo.empty) {
                    continue;
                }
                if (tableName === 'glyf') {
                    writer.writeBytes(newGlyphTable);
                }
                else if (tableName === 'loca') {
                    writer.writeBytes(newLocaTable);
                }
                else {
                    var count = this.align(tableInfo.length);
                    var buff = [];
                    for (var i_1 = 0; i_1 < count; i_1++) {
                        buff.push(0);
                    }
                    this.offset = tableInfo.offset;
                    var result = this.read(buff, 0, tableInfo.length);
                    writer.writeBytes(result.buffer);
                }
            }
        };
        TtfReader.prototype.setOffset = function (offset) {
            this.offset = offset;
        };
        TtfReader.prototype.createInternals = function () {
            this.metrics = new ttf_metrics_1.TtfMetrics();
            var nameTable = this.readNameTable();
            var headTable = this.readHeadTable();
            this.bIsLocaShort = (headTable.indexToLocalFormat === 0);
            var horizontalHeadTable = this.readHorizontalHeaderTable();
            var os2Table = this.readOS2Table();
            var postTable = this.readPostTable();
            this.width = this.readWidthTable(horizontalHeadTable.numberOfHMetrics, headTable.unitsPerEm);
            var subTables = this.readCmapTable();
            this.initializeMetrics(nameTable, headTable, horizontalHeadTable, os2Table, postTable, subTables);
        };
        TtfReader.prototype.getGlyph = function (charCode) {
            var obj = null;
            var code = charCode.charCodeAt(0);
            if (!this.metrics.isSymbol && this.microsoft !== null) {
                if (this.microsoft.containsKey(code)) {
                    obj = this.microsoft.getValue(code);
                    if (code !== string_tokenizer_1.StringTokenizer.whiteSpace.charCodeAt(0)) {
                        this.isFontPresent = true;
                    }
                }
                else if (code !== string_tokenizer_1.StringTokenizer.whiteSpace.charCodeAt(0)) {
                    this.isFontPresent = false;
                }
            }
            else if (this.metrics.isSymbol && this.macintosh !== null || this.isMacTTF) {
                if (this.maxMacIndex !== 0) {
                    code %= this.maxMacIndex + 1;
                }
                else {
                    code = ((code & 0xff00) === 0xf000 ? code & 0xff : code);
                }
                if (this.macintosh.containsKey(code)) {
                    obj = this.macintosh.getValue(code);
                    this.isFontPresent = true;
                }
            }
            if (charCode === string_tokenizer_1.StringTokenizer.whiteSpace && obj === null) {
                obj = new ttf_glyph_info_1.TtfGlyphInfo();
            }
            var glyph = (obj !== null) ? obj : this.getDefaultGlyph();
            return glyph;
        };
        TtfReader.prototype.getGlyphChars = function (chars) {
            if (chars === null || chars === undefined) {
                throw new Error('Argument Null Exception : chars');
            }
            var dictionary = new dictionary_1.Dictionary();
            var charKeys = chars.keys();
            for (var i = 0; i < charKeys.length; i++) {
                var ch = charKeys[i];
                var glyph = this.getGlyph(ch);
                if (!glyph.empty) {
                    dictionary.setValue(glyph.index, ch.charCodeAt(0));
                }
            }
            return dictionary;
        };
        TtfReader.prototype.getAllGlyphs = function () {
            var allGlyphInfo = [];
            var info = new ttf_glyph_info_1.TtfGlyphInfo();
            var index = 0;
            for (var i = 0; i < this.width.length; i++) {
                var width = this.width[i];
                info.index = index;
                info.width = width;
                allGlyphInfo.push(info);
                index++;
            }
            return allGlyphInfo;
        };
        TtfReader.prototype.readFontProgram = function (chars) {
            var glyphChars = this.getGlyphChars(chars);
            var locaTable = this.readLocaTable(this.bIsLocaShort);
            if (glyphChars.size() < chars.size()) {
                this.missedGlyphs = chars.size() - glyphChars.size();
            }
            this.updateGlyphChars(glyphChars, locaTable);
            var result1 = this.generateGlyphTable(glyphChars, locaTable, null, null);
            var glyphTableSize = result1.glyphTableSize;
            var newLocaTable = result1.newLocaTable;
            var newGlyphTable = result1.newGlyphTable;
            var result2 = this.updateLocaTable(newLocaTable, this.bIsLocaShort, null);
            var newLocaSize = result2.newLocaSize;
            var newLocaUpdated = result2.newLocaUpdated;
            var fontProgram = this.getFontProgram(newLocaUpdated, newGlyphTable, glyphTableSize, newLocaSize);
            return fontProgram;
        };
        TtfReader.prototype.convertString = function (text) {
            if (text === null) {
                throw new Error('Argument Null Exception : text');
            }
            var glyph = '';
            var i = 0;
            for (var k = 0; k < text.length; k++) {
                var ch = text[k];
                var glyphInfo = this.getGlyph(ch);
                if (!glyphInfo.empty) {
                    glyph += String.fromCharCode(glyphInfo.index);
                    i++;
                }
            }
            return glyph;
        };
        TtfReader.prototype.getCharWidth = function (code) {
            var glyphInfo = this.getGlyph(code);
            glyphInfo = (!glyphInfo.empty) ? glyphInfo : this.getDefaultGlyph();
            var codeWidth = (!glyphInfo.empty) ? glyphInfo.width : 0;
            return codeWidth;
        };
        TtfReader.prototype.readString = function (length, isUnicode) {
            if (isUnicode === undefined) {
                return this.readString(length, false);
            }
            else {
                var result = '';
                if (isUnicode) {
                    for (var i = 0; i < length; i++) {
                        if (i % 2 !== 0) {
                            result += String.fromCharCode(this.fontData[this.offset]);
                        }
                        this.offset += 1;
                    }
                }
                else {
                    for (var i = 0; i < length; i++) {
                        result += String.fromCharCode(this.fontData[this.offset]);
                        this.offset += 1;
                    }
                }
                return result;
            }
        };
        TtfReader.prototype.readFixed = function (offset) {
            var integer = this.readInt16(offset);
            var sFraction = this.readInt16(offset + 2);
            var fraction = sFraction / 16384;
            return integer + fraction;
        };
        TtfReader.prototype.readInt32 = function (offset) {
            var i1 = this.fontData[offset + 3];
            var i2 = this.fontData[offset + 2];
            var i3 = this.fontData[offset + 1];
            var i4 = this.fontData[offset];
            this.offset += 4;
            return i1 + (i2 << 8) + (i3 << 16) + (i4 << 24);
        };
        TtfReader.prototype.readUInt32 = function (offset) {
            var i1 = this.fontData[offset + 3];
            var i2 = this.fontData[offset + 2];
            var i3 = this.fontData[offset + 1];
            var i4 = this.fontData[offset];
            this.offset += 4;
            return (i1 | i2 << 8 | i3 << 16 | i4 << 24);
        };
        TtfReader.prototype.readInt16 = function (offset) {
            var result = (this.fontData[offset] << 8) + this.fontData[offset + 1];
            result = result & (1 << 15) ? result - 0x10000 : result;
            this.offset += 2;
            return result;
        };
        TtfReader.prototype.readInt64 = function (offset) {
            var low = this.readInt32(offset + 4);
            var n = this.readInt32(offset) * 4294967296.0 + low;
            if (low < 0) {
                n += 4294967296;
            }
            return n;
        };
        TtfReader.prototype.readUInt16 = function (offset) {
            var result = (this.fontData[offset] << 8) | this.fontData[offset + 1];
            this.offset += 2;
            return result;
        };
        TtfReader.prototype.readUshortArray = function (length) {
            var buffer = [];
            for (var i = 0; i < length; i++) {
                buffer[i] = this.readUInt16(this.offset);
            }
            return buffer;
        };
        TtfReader.prototype.readBytes = function (length) {
            var result = [];
            for (var i = 0; i < length; i++) {
                result.push(this.fontData[this.offset]);
                this.offset += 1;
            }
            return result;
        };
        TtfReader.prototype.readByte = function (offset) {
            var result = this.fontData[offset];
            this.offset += 1;
            return result;
        };
        TtfReader.prototype.read = function (buffer, index, count) {
            if (buffer === null) {
                throw new Error('Argument Null Exception : buffer');
            }
            var written = 0;
            var read = 0;
            do {
                for (var i = 0; (i < count - written) && (this.offset + i < this.fontData.length); i++) {
                    buffer[index + i] = this.fontData[this.offset + i];
                }
                read = count - written;
                this.offset += read;
                written += read;
            } while (written < count);
            return { buffer: buffer, written: written };
        };
        return TtfReader;
    }());
    exports.TtfReader = TtfReader;
});
