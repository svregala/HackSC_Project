define(["require", "exports", "./../../graphics/images/index", "./ttf-reader", "./../../primitives/pdf-dictionary", "./../../primitives/pdf-stream", "./../../primitives/pdf-stream", "./../../primitives/pdf-array", "./../../primitives/pdf-name", "./../../primitives/pdf-number", "./../../primitives/pdf-string", "./../../primitives/pdf-reference", "./pdf-font-metrics", "./pdf-font-metrics", "./../../input-output/pdf-dictionary-properties", "./../../collections/dictionary", "./enum", "./../../drawing/pdf-drawing", "./../../input-output/pdf-operators"], function (require, exports, index_1, ttf_reader_1, pdf_dictionary_1, pdf_stream_1, pdf_stream_2, pdf_array_1, pdf_name_1, pdf_number_1, pdf_string_1, pdf_reference_1, pdf_font_metrics_1, pdf_font_metrics_2, pdf_dictionary_properties_1, dictionary_1, enum_1, pdf_drawing_1, pdf_operators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnicodeTrueTypeFont = (function () {
        function UnicodeTrueTypeFont(base64String, size) {
            this.nameString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            this.dictionaryProperties = new pdf_dictionary_properties_1.DictionaryProperties();
            this.isCompress = false;
            this.cmapPrefix = '/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap' + pdf_operators_1.Operators.newLine + '/CIDSystemInfo << /Registry (Adobe)/Ordering (UCS)/Supplement 0>> def\n/CMapName ' + '/Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange' + pdf_operators_1.Operators.newLine;
            this.cmapEndCodespaceRange = 'endcodespacerange' + pdf_operators_1.Operators.newLine;
            this.cmapBeginRange = 'beginbfrange' + pdf_operators_1.Operators.newLine;
            this.cmapEndRange = 'endbfrange' + pdf_operators_1.Operators.newLine;
            this.cmapSuffix = 'endbfrange\nendcmap\nCMapName currentdict ' + '/CMap defineresource pop\nend end' + pdf_operators_1.Operators.newLine;
            if (base64String === null || base64String === undefined) {
                throw new Error('ArgumentNullException:base64String');
            }
            this.fontSize = size;
            this.fontString = base64String;
            this.Initialize();
        }
        UnicodeTrueTypeFont.prototype.getCharWidth = function (charCode) {
            var codeWidth = this.ttfReader.getCharWidth(charCode);
            return codeWidth;
        };
        UnicodeTrueTypeFont.prototype.Initialize = function () {
            var byteArray = new index_1.ByteArray(this.fontString.length);
            byteArray.writeFromBase64String(this.fontString);
            this.fontData = byteArray.internalBuffer;
            this.ttfReader = new ttf_reader_1.TtfReader(this.fontData);
            this.ttfMetrics = this.ttfReader.metrics;
        };
        UnicodeTrueTypeFont.prototype.createInternals = function () {
            this.fontDictionary = new pdf_dictionary_1.PdfDictionary();
            this.fontProgram = new pdf_stream_2.PdfStream();
            this.cmap = new pdf_stream_2.PdfStream();
            this.descendantFont = new pdf_dictionary_1.PdfDictionary();
            this.metrics = new pdf_font_metrics_1.PdfFontMetrics();
            this.ttfReader.createInternals();
            this.ttfMetrics = this.ttfReader.metrics;
            this.initializeMetrics();
            this.subsetName = this.getFontName();
            this.createDescendantFont();
            this.createCmap();
            this.createFontDictionary();
            this.createFontProgram();
        };
        UnicodeTrueTypeFont.prototype.getInternals = function () {
            return this.fontDictionary;
        };
        UnicodeTrueTypeFont.prototype.initializeMetrics = function () {
            var ttfMetrics = this.ttfReader.metrics;
            this.metrics.ascent = ttfMetrics.macAscent;
            this.metrics.descent = ttfMetrics.macDescent;
            this.metrics.height = ttfMetrics.macAscent - ttfMetrics.macDescent + ttfMetrics.lineGap;
            this.metrics.name = ttfMetrics.fontFamily;
            this.metrics.postScriptName = ttfMetrics.postScriptName;
            this.metrics.size = this.fontSize;
            this.metrics.widthTable = new pdf_font_metrics_2.StandardWidthTable(ttfMetrics.widthTable);
            this.metrics.lineGap = ttfMetrics.lineGap;
            this.metrics.subScriptSizeFactor = ttfMetrics.subScriptSizeFactor;
            this.metrics.superscriptSizeFactor = ttfMetrics.superscriptSizeFactor;
            this.metrics.isBold = ttfMetrics.isBold;
        };
        UnicodeTrueTypeFont.prototype.getFontName = function () {
            var builder = '';
            var name;
            for (var i = 0; i < 6; i++) {
                var index = Math.floor(Math.random() * (25 - 0 + 1)) + 0;
                builder += this.nameString[index];
            }
            builder += '+';
            builder += this.ttfReader.metrics.postScriptName;
            name = builder.toString();
            name = this.formatName(name);
            return name;
        };
        UnicodeTrueTypeFont.prototype.formatName = function (fontName) {
            var ret = fontName.replace('(', '#28');
            ret = ret.replace(')', '#29');
            ret = ret.replace('[', '#5B');
            ret = ret.replace(']', '#5D');
            ret = ret.replace('<', '#3C');
            ret = ret.replace('>', '#3E');
            ret = ret.replace('{', '#7B');
            ret = ret.replace('}', '#7D');
            ret = ret.replace('/', '#2F');
            ret = ret.replace('%', '#25');
            return ret.replace(' ', '#20');
        };
        UnicodeTrueTypeFont.prototype.createDescendantFont = function () {
            this.descendantFont.isFont = true;
            this.descendantFont.descendantFontBeginSave = new pdf_dictionary_1.SaveDescendantFontEventHandler(this);
            this.descendantFont.items.setValue(this.dictionaryProperties.type, new pdf_name_1.PdfName(this.dictionaryProperties.font));
            this.descendantFont.items.setValue(this.dictionaryProperties.subtype, new pdf_name_1.PdfName(this.dictionaryProperties.cIDFontType2));
            this.descendantFont.items.setValue(this.dictionaryProperties.baseFont, new pdf_name_1.PdfName(this.subsetName));
            this.descendantFont.items.setValue(this.dictionaryProperties.cIDToGIDMap, new pdf_name_1.PdfName(this.dictionaryProperties.identity));
            this.descendantFont.items.setValue(this.dictionaryProperties.dw, new pdf_number_1.PdfNumber(1000));
            this.fontDescriptor = this.createFontDescriptor();
            this.descendantFont.items.setValue(this.dictionaryProperties.fontDescriptor, new pdf_reference_1.PdfReferenceHolder(this.fontDescriptor));
            var systemInfo = this.createSystemInfo();
            this.descendantFont.items.setValue(this.dictionaryProperties.cIDSystemInfo, systemInfo);
        };
        UnicodeTrueTypeFont.prototype.createFontDescriptor = function () {
            var descriptor = new pdf_dictionary_1.PdfDictionary();
            var metrics = this.ttfReader.metrics;
            descriptor.isFont = true;
            descriptor.items.setValue(this.dictionaryProperties.type, new pdf_name_1.PdfName(this.dictionaryProperties.fontDescriptor));
            descriptor.items.setValue(this.dictionaryProperties.fontName, new pdf_name_1.PdfName(this.subsetName));
            descriptor.items.setValue(this.dictionaryProperties.flags, new pdf_number_1.PdfNumber(this.getDescriptorFlags()));
            descriptor.items.setValue(this.dictionaryProperties.fontBBox, pdf_array_1.PdfArray.fromRectangle(this.getBoundBox()));
            descriptor.items.setValue(this.dictionaryProperties.missingWidth, new pdf_number_1.PdfNumber(metrics.widthTable[32]));
            descriptor.items.setValue(this.dictionaryProperties.stemV, new pdf_number_1.PdfNumber(metrics.stemV));
            descriptor.items.setValue(this.dictionaryProperties.italicAngle, new pdf_number_1.PdfNumber(metrics.italicAngle));
            descriptor.items.setValue(this.dictionaryProperties.capHeight, new pdf_number_1.PdfNumber(metrics.capHeight));
            descriptor.items.setValue(this.dictionaryProperties.ascent, new pdf_number_1.PdfNumber(metrics.winAscent));
            descriptor.items.setValue(this.dictionaryProperties.descent, new pdf_number_1.PdfNumber(metrics.winDescent));
            descriptor.items.setValue(this.dictionaryProperties.leading, new pdf_number_1.PdfNumber(metrics.leading));
            descriptor.items.setValue(this.dictionaryProperties.avgWidth, new pdf_number_1.PdfNumber(metrics.widthTable[32]));
            descriptor.items.setValue(this.dictionaryProperties.fontFile2, new pdf_reference_1.PdfReferenceHolder(this.fontProgram));
            descriptor.items.setValue(this.dictionaryProperties.maxWidth, new pdf_number_1.PdfNumber(metrics.widthTable[32]));
            descriptor.items.setValue(this.dictionaryProperties.xHeight, new pdf_number_1.PdfNumber(0));
            descriptor.items.setValue(this.dictionaryProperties.stemH, new pdf_number_1.PdfNumber(0));
            return descriptor;
        };
        UnicodeTrueTypeFont.prototype.createCmap = function () {
            this.cmap.cmapBeginSave = new pdf_stream_1.SaveCmapEventHandler(this);
        };
        UnicodeTrueTypeFont.prototype.createFontDictionary = function () {
            this.fontDictionary.isFont = true;
            this.fontDictionary.fontDictionaryBeginSave = new pdf_dictionary_1.SaveFontDictionaryEventHandler(this);
            this.fontDictionary.items.setValue(this.dictionaryProperties.type, new pdf_name_1.PdfName(this.dictionaryProperties.font));
            this.fontDictionary.items.setValue(this.dictionaryProperties.baseFont, new pdf_name_1.PdfName(this.subsetName));
            this.fontDictionary.items.setValue(this.dictionaryProperties.subtype, new pdf_name_1.PdfName(this.dictionaryProperties.type0));
            this.fontDictionary.items.setValue(this.dictionaryProperties.encoding, new pdf_name_1.PdfName(this.dictionaryProperties.identityH));
            var descFonts = new pdf_array_1.PdfArray();
            var reference = new pdf_reference_1.PdfReferenceHolder(this.descendantFont);
            descFonts.isFont = true;
            descFonts.add(reference);
            this.fontDictionary.items.setValue(this.dictionaryProperties.descendantFonts, descFonts);
        };
        UnicodeTrueTypeFont.prototype.createFontProgram = function () {
            this.fontProgram.fontProgramBeginSave = new pdf_stream_1.SaveFontProgramEventHandler(this);
        };
        UnicodeTrueTypeFont.prototype.createSystemInfo = function () {
            var systemInfo = new pdf_dictionary_1.PdfDictionary();
            systemInfo.items.setValue(this.dictionaryProperties.registry, new pdf_string_1.PdfString('Adobe'));
            systemInfo.items.setValue(this.dictionaryProperties.ordering, new pdf_string_1.PdfString(this.dictionaryProperties.identity));
            systemInfo.items.setValue(this.dictionaryProperties.supplement, new pdf_number_1.PdfNumber(0));
            return systemInfo;
        };
        UnicodeTrueTypeFont.prototype.descendantFontBeginSave = function () {
            if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {
                var width = this.getDescendantWidth();
                if (width !== null) {
                    this.descendantFont.items.setValue(this.dictionaryProperties.w, width);
                }
            }
        };
        UnicodeTrueTypeFont.prototype.cmapBeginSave = function () {
            this.generateCmap();
        };
        UnicodeTrueTypeFont.prototype.fontDictionaryBeginSave = function () {
            if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0 && !this.fontDictionary.containsKey(this.dictionaryProperties.toUnicode)) {
                this.fontDictionary.items.setValue(this.dictionaryProperties.toUnicode, new pdf_reference_1.PdfReferenceHolder(this.cmap));
            }
        };
        UnicodeTrueTypeFont.prototype.fontProgramBeginSave = function () {
            this.isCompress = true;
            this.generateFontProgram();
        };
        UnicodeTrueTypeFont.prototype.getDescendantWidth = function () {
            var array = new pdf_array_1.PdfArray();
            if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {
                var glyphInfo = [];
                var keys = this.usedChars.keys();
                for (var i = 0; i < keys.length; i++) {
                    var chLen = keys[i];
                    var glyph = this.ttfReader.getGlyph(chLen);
                    if (glyph.empty) {
                        continue;
                    }
                    glyphInfo.push(glyph);
                }
                glyphInfo.sort(function (a, b) { return a.index - b.index; });
                var firstGlyphIndex = 0;
                var lastGlyphIndex = 0;
                var firstGlyphIndexWasSet = false;
                var widthDetails = new pdf_array_1.PdfArray();
                for (var i = 0; i < glyphInfo.length; i++) {
                    var glyph = glyphInfo[i];
                    if (!firstGlyphIndexWasSet) {
                        firstGlyphIndexWasSet = true;
                        firstGlyphIndex = glyph.index;
                        lastGlyphIndex = glyph.index - 1;
                    }
                    if ((lastGlyphIndex + 1 !== glyph.index || (i + 1 === glyphInfo.length)) && glyphInfo.length > 1) {
                        array.add(new pdf_number_1.PdfNumber(firstGlyphIndex));
                        if (i !== 0) {
                            array.add(widthDetails);
                        }
                        firstGlyphIndex = glyph.index;
                        widthDetails = new pdf_array_1.PdfArray();
                    }
                    widthDetails.add(new pdf_number_1.PdfNumber(glyph.width));
                    if (i + 1 === glyphInfo.length) {
                        array.add(new pdf_number_1.PdfNumber(firstGlyphIndex));
                        array.add(widthDetails);
                    }
                    lastGlyphIndex = glyph.index;
                }
            }
            return array;
        };
        UnicodeTrueTypeFont.prototype.generateCmap = function () {
            if (this.usedChars !== null && this.usedChars !== undefined && this.usedChars.size() > 0) {
                var glyphChars = this.ttfReader.getGlyphChars(this.usedChars);
                if (glyphChars.size() > 0) {
                    var keys = glyphChars.keys().sort();
                    var first = keys[0];
                    var last = keys[keys.length - 1];
                    var middlePart = this.toHexString(first, false) + this.toHexString(last, false) + pdf_operators_1.Operators.newLine;
                    var builder = '';
                    builder += this.cmapPrefix;
                    builder += middlePart;
                    builder += this.cmapEndCodespaceRange;
                    var nextRange = 0;
                    for (var i = 0; i < keys.length; i++) {
                        if (nextRange === 0) {
                            if (i !== 0) {
                                builder += this.cmapEndRange;
                            }
                            nextRange = Math.min(100, keys.length - i);
                            builder += nextRange;
                            builder += pdf_operators_1.Operators.whiteSpace;
                            builder += this.cmapBeginRange;
                        }
                        nextRange -= 1;
                        var key = keys[i];
                        builder += this.toHexString(key, true) + this.toHexString(key, true) + this.toHexString(glyphChars.getValue(key), true) + '\n';
                    }
                    builder += this.cmapSuffix;
                    this.cmap.clearStream();
                    this.cmap.isFont = true;
                    this.cmap.write(builder);
                }
            }
        };
        UnicodeTrueTypeFont.prototype.generateFontProgram = function () {
            var fontProgram = null;
            this.usedChars = (this.usedChars === null || this.usedChars === undefined) ? new dictionary_1.Dictionary() : this.usedChars;
            this.ttfReader.setOffset(0);
            fontProgram = this.ttfReader.readFontProgram(this.usedChars);
            this.fontProgram.clearStream();
            this.fontProgram.isFont = true;
            this.fontProgram.writeBytes(fontProgram);
        };
        UnicodeTrueTypeFont.prototype.getDescriptorFlags = function () {
            var flags = 0;
            var metrics = this.ttfReader.metrics;
            if (metrics.isFixedPitch) {
                flags |= enum_1.FontDescriptorFlags.FixedPitch;
            }
            if (metrics.isSymbol) {
                flags |= enum_1.FontDescriptorFlags.Symbolic;
            }
            else {
                flags |= enum_1.FontDescriptorFlags.Nonsymbolic;
            }
            if (metrics.isItalic) {
                flags |= enum_1.FontDescriptorFlags.Italic;
            }
            if (metrics.isBold) {
                flags |= enum_1.FontDescriptorFlags.ForceBold;
            }
            return flags;
        };
        UnicodeTrueTypeFont.prototype.getBoundBox = function () {
            var rect = this.ttfReader.metrics.fontBox;
            var width = Math.abs(rect.right - rect.left);
            var height = Math.abs(rect.top - rect.bottom);
            var rectangle = new pdf_drawing_1.RectangleF(rect.left, rect.bottom, width, height);
            return rectangle;
        };
        UnicodeTrueTypeFont.prototype.toHexString = function (n, isCaseChange) {
            var s = n.toString(16);
            if (isCaseChange) {
                s = s.toUpperCase();
            }
            return '<0000'.substring(0, 5 - s.length) + s + '>';
        };
        UnicodeTrueTypeFont.prototype.setSymbols = function (text) {
            if (text === null) {
                throw new Error('Argument Null Exception : text');
            }
            if (this.usedChars === null || this.usedChars === undefined) {
                this.usedChars = new dictionary_1.Dictionary();
            }
            for (var i = 0; i < text.length; i++) {
                var ch = text[i];
                this.usedChars.setValue(ch, String.fromCharCode(0));
            }
            this.getDescendantWidth();
        };
        return UnicodeTrueTypeFont;
    }());
    exports.UnicodeTrueTypeFont = UnicodeTrueTypeFont;
});
